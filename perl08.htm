<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Author" content="Юрий Лукач">
<meta name="Description" content="Справочник Веб-разработчика: современные технологии WWW">
<meta name="Keywords" content="WWW, Веб, разработка, программирование, HTML, DHTML, CSS, Java, JavaScript, CGI, PERL, ASP, XML, XSL, VML, VRML">
<title>WDH: PERL - Классы и объекты</title>
<link rel="Prev" href="perl07.htm" title="Пакеты и модули">
<link rel="Next" href="perl09.htm" title="Встроенные функции">
<link rel="Copyright" href="cpyright.htm" title="Сведения об авторских правах">
<link rev="Made" href="mailto:yury@suncloud.ru" title="Обратная связь">
<script type="text/javascript" src="global/load.js"></script>
<script type="text/javascript" src="global/link.js"></script>
</head>

<body onLoad="initDoc(); addBanner(true)">
<table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin: 0">
  <tr><td><div id="divHeader"></div></td></tr>
  <tr><td id="tdBanner" style="text-align: center"><script type="text/javascript">addBanner(false);</script></td></tr>
  <tr><td>

      <h2><a name="ref68">Глава 6.8. Классы и объекты</a></h2>

      <h3><a name="ref681">6.8.1. Классы, объекты и методы</a></h3>

      <p>После краткого знакомства с модулями мы можем теперь перейти к подробному описанию их применения для
        создания объектно-ориентированных программ. К объектному программированию относятся по-разному: одни как
        к единственному верному способу программирования, другие как к модной причуде. Автор считает,
        что объектный подход позволяет быстро и четко формализовать постановку задачи на языках программирования,
        поэтому дальнейшее описание создания модулей и работы с ними построено именно на фундаменте этого подхода.</p>

      <p>Как известно, объектно-ориентированное программирование основано на двух базовых понятиях: классы и объекты.
        <em>Класс</em>&nbsp;&#151; это абстракция, описывающая некие свойства (данные класса и методы работы с ними).
        <em>Объект</em>&nbsp;&#151; это конкретный экземпляр класса, реализующий его свойства.</p>

      <p>PERL не содержит ни классов, ни объектов в традиционном их понимании. Тем не менее, объектное программирование
        на нем вполне возможно, если руководствоваться тремя правилами, сформулированными создателями этого языка:</p>
      <ol>
        <li>Класс&nbsp;&#151; это модуль, создающий объекты и обеспечивающий доступ к их методам.</li>
        <li>Объект&nbsp;&#151; это ссылка на класс, &quot;освященная&quot; специальной функцией <tt>bless()</tt>.</li>
        <li>Метод&nbsp;&#151; это подпрограмма, первым аргументом которой является ссылка на объект или имя модуля.</li>
      </ol>
      <p>Давайте рассмотрим эти правила более подробно.</p>

      <h3><a name="ref682">6.8.2. Создание классов</a></h3>

      <p>Мы сказали, что класс в PERLе&nbsp;&#151; это просто модуль с определенными свойствами. Поэтому начнем с создания модуля, на примере которого
        будем демонстрировать вводимые далее понятия. В качестве примера возьмем класс Browser, описывающий Веб-обозреватели,
        которым мы пользовались в <a href="js07.htm#ref371">п. 3.7.1</a> при описании JavaScript и создадим его на языке PERL.
        Назовем этот пакет Info::Browser и соответственно разместим его в файле Info/Browser.pm.</p>

      <p>В модуле Info::Browser мы не будем пользоваться модулем Explorer, поскольку он не экспортирует никаких символов. Прежде всего,
        мы должны определить структуру данных нашего класса. Чаще всего структура классов реализуется безымянными ассоциативными массивами, в которых
        поля данных индексируются их названиями. Для модуля Info::Browser мы используем ассоциативный массив с тремя полями данных: строка <tt>NAME</tt> (название
        обозревателя), число <tt>VERSION</tt> (номер версии) и массив <tt>OPTIONS</tt> из двух логических значений (первое значение указывает, разрешен ли вызов Java-аплетов,
        второе&nbsp;&#151; разрешены ли куки).</p>

      <p>Далее нам нужен метод, создающий объекты данного класса. Такие методы называются <em>конструкторами</em> и могут носить любое имя.
        Однако, большинство программистов на PERLе называют их либо именем <tt>new()</tt>, либо именем класса. Наш конструктор выглядит так:</p>

      <div class="code">
<pre class="code">sub new {
  my $self  = {};           # ссылка на безымянный пустой ассоциативный массив
  $self->{NAME}    = undef; # инициализация его полей неопределенными значениями
  $self->{VERSION} = undef;
  $self->{OPTIONS} = [];    # ссылка на безымянный пустой массив
  bless($self);             # $self становится объектом
  return $self;
}</pre>
      </div>

      <p>Здесь в комментариях нуждается только функция <tt>bless</tt>. Она имеет две формы</p>

<pre class="syntax"><a name="fbless"></a>bless <em>ref</em>, <em>class</em>
bless <em>ref</em></pre>

      <p>Эта функция сообщает содержимому ссылки <tt><em>ref</em></tt>, что оно является объектом класса <tt><em>class</em></tt>.
        Если <tt><em>class</em></tt> опущен, то используется текущий пакет. Функция <tt>bless</tt> возвращает ссылку <tt><em>ref</em></tt>,
        поэтому оператор <strong>return</strong> в нашем конструкторе не обязателен и введен только для ясности.</p>

      <p>Тепеь мы готовы написать полный текст модуля Info::Browser. Помимо конструктора он содержит три метода <tt>name()</tt>, <tt>version()</tt> и <tt>options()</tt>,
        которые обеспечивают доступ к полям данных наших объектов. Эти методы следуют такому соглашению: если они вызваны без аргументов, то возвращают текущее значение поля,
        а если с аргументом, то заносят его в соответствующее поле данных.</p>

      <div class="code">
<pre class="code">package Info::Browser;
use strict;

sub new {
  my $self  = {};
  $self->{NAME}    = undef;
  $self->{VERSION} = undef;
  $self->{OPTIONS} = [];
  bless($self);
  return $self;
}
sub name {
  my $self = shift;
  if (@_) { $self->{NAME} = shift }
  return $self->{NAME};
}
sub version {
  my $self = shift;
  if (@_) { $self->{VERSION} = shift }
  return $self->{VERSION};
}
sub options {
  my $self = shift;
  if (@_) { @{ $self->{OPTIONS} } = @_ }
  return $self->{OPTIONS};
}

1;  # для функций require или use</pre>
      </div>

      <p>Следующий пример показывает, как создать объект класса Info::Browser и инициализировать его поля:</p>

      <div class="code">
<pre class="code">use Browser;
$myBrowser = Browser->new();
$myBrowser->name("Opera");
$myBrowser->version(5);
$myBrowser->options(1, 0);
printf "%s %d : ", $myBrowser->name, $myBrowser->version;
printf "Java %s, ", $myBrowser->options->[0] ? "enabled" : "disabled";
printf "Cookies %s.\n", $myBrowser->options->[1] ? "enabled" : "disabled";</pre>
      </div>

      <p>Обратите внимание, что пользователю нашего модуля не нужны подробности его реализации. Он просто вызывает конструктор,
        а затем обращается к его методам.</p>

      <p>Созданный нами модуль вполне работоспособен, но его конструктор имеет два недостатка. Во-первых, он вызывается только как
      метод класса, но не как метод объекта. Иными словами, мы не можем написать</p>

      <div class="code">
<pre class="code">$x = Browser->new();
$y = $x->new();</pre>
      </div>

      <p>Во-вторых, функция <tt>bless</tt> в нем жестко привязана к классу Info::Browser, поскольку мы вызываем ее без второго аргумента.
        Если мы в дальнейшем захотим создавать классы, являющиеся потомками Info::Browser, то должны вызывать <tt>bless</tt> с двумя аргументами,
        помня, что любому методу класса этот класс передается в качестве первого аргумента. С учетом этих замечаний
        наш конструктор принимает вид:</p>

      <div class="code">
<pre class="code">sub new {
  my $proto = shift;                 # извлекаем имя класса или указатель на объект
  my $class = ref($proto) || $proto; # если указатель, то взять из него имя класса
  my $self  = {};
  $self->{NAME}    = undef;
  $self->{VERSION} = undef;
  $self->{OPTIONS} = [];
  bless($self, $class);              # гибкий вызов функции bless
  return $self;
}</pre>
      </div>

      <p>Все приведенные выше методы работали с полями данных объекта. Разумеется, возможности методов этим не ограничены.
        Мы можем, например, добавить к нашему классу такой метод:</p>

      <div class="code">
<pre class="code">sub showObject {
  my $self = shift;
  printf "%s %d : ", $self->name, $self->version;
  printf "Java %s, ", $self->options->[0] ? "enabled" : "disabled";
  printf "Cookies %s.\n", $self->options->[1] ? "enabled" : "disabled";
}</pre>
      </div>

      <h3><a name="ref683">6.8.3. Деструкторы объектов</a></h3>

      <p>Большинство языков программирования, поддерживающих создание объектов через конструкторы, поддерживают и деструкторы объектов.
        <em>Деструктор</em>&nbsp;&#151; это метод, который автоматически вызывается исполняющей средой, когда происходит удаление объекта.
        В отличие от конструктора он обязан иметь единственное возможное имя, а именно <tt>DESTROY</tt>. Причина этого состоит именно в том,
        что он чаще всего вызывается автоматически системой сборки мусора, которая требует, чтобы все деструкторы назывались одинаково.</p>

      <p>Хотя деструкторы объектов в PERLе и предусмотрены, писать их приходится крайне редко, опять-таки благодаря наличию системы сборки мусора.
        По сути дела, единственная ситуация, в которой написание деструктора необходимо, это объекты, содержащие прямую или опосредованную ссылку
        на себя. Такой объект никогда не будет автоматически удален (во всяком случае, пока программа не завершится), и, если мы озабочены
        оптимизацией памяти, то должны явно вызвать деструктор этого объекта.</p>

      <h3><a name="ref684">6.8.4. Данные класса</a></h3>

      <p>До сих пор все данные в нашем классе были данными объекта, т.&nbsp;е. относились к конкретному экземпляру класса. Однако, во многих случаях
        бывают нужны переменные, относящиеся к классу в целом. В нашем примере такой переменной могла бы быть переменная <tt>$Count</tt>, содержащая количество
        существующих экземпляров класса. С ее использованием начало модуля выглядит так:</p>

      <div class="code">
<pre class="code">package Browser;
use strict;

my $Count = 0;

sub new {
  my $proto = shift;
  my $class = ref($proto) || $proto;
  $Count++;
  my $self  = {};
  $self->{NAME}    = undef;
  $self->{VERSION} = undef;
  $self->{OPTIONS} = [];
  bless($self, $class);
  return $self;
}
sub DESTROY {
  $Count--;
}
sub total {
  return $Count;
}</pre>
      </div>

      <p>Как мы видим, добавились метод <tt>total()</tt>, возвращающий значение <tt>$Count</tt>, и деструктор объектов, необходимый для
        правильного подсчета существующих объектов.</p>

      <p>Данные и методы, относящиеся к классу в целом, а не к его экземплярам, называются <em>статическими</em>.</p>

      <h3><a name="ref685">6.8.5. Наследование</a></h3>

      <p>Все объектно-ориентированные системы программирования включают в себя понятие <em>наследования</em>. Наследование означает, что создаваемый
        класс может быть объявлен потомком уже существующего класса. Потомок класса наследует все его свойства, но может дополнительно иметь собственные
        свойства или изменять унаследованные свойства.</p>

      <p>PERL не поддерживает наследование классов. Вместо этого каждый пакет содержит переменную <tt>@ISA</tt>,
        управляющую наследованием методов. Если мы вызываем метод класса или объекта, которого нет в пакете данного класса, то PERL просматривает пакеты, перечисленные в
        <tt>@ISA</tt>, в поисках метода с таким именем. Рассмотрим такой пакет:</p>

      <div class="code">
<pre class="code">package Info::System;
use Info::Browser;
@ISA = qw(Info::Browser);
1;</pre>
      </div>

      <p>Этот короткий модуль создает новый класс Info::System, который наследует все методы класса Info::Browser.
        Например, мы могли бы написать такую программу:</p>

      <div class="code">
<pre class="code">use Info::System;
$myBrowser = Info::System->new();
$myBrowser->name("Netscape");
$myBrowser->version(6);
$myBrowser->options(1, 1);
$myBrowser->showObject;
print "Total: ".Info::System->total()."\n";</pre>
      </div>

      <p>Посмотрим, что происходит при вызове метода <tt>Info::System->new()</tt>. Поскольку в пакете Info::System
        такого метода нет, PERL ищет его в массиве <tt>@ISA</tt> и находит в пакете Info::Browser. Затем он вызывает
        этот метод, передавая ему в качестве первого аргумента имя класса Info::System, т.&nbsp;е. данный оператор
        заменяется на <tt>Info::Browser::new("Info::System")</tt>. После этого срабатывает функция <tt>bless</tt>,
        вторым аргументом которой является имя переданного класса, как описано выше. В результате мы получаем
        ссылку на вновь созданный объект класса Info::System, что нам и требовалось.</p>

      <p>Теперь мы можем добавить к классу Info::System его собственные методы, например:</p>

      <div class="code">
<pre class="code">sub osname {
  my $self = shift;
  if (@_) { $self->{OSNAME} = shift }
  return $self->{OSNAME};
}</pre>
      </div>

      <p>Больше того, мы можем переопределить в Info::System часть методов класса Info::Browser, например:</p>

      <div class="code">
<pre class="code">sub showObject {
  my $self = shift;
  printf "%s %d on %s: ", $self->name, $self->version, $self->osname;
  printf "Java %s, ", $self->options->[0] ? "enabled" : "disabled";
  printf "Cookies %s.\n", $self->options->[1] ? "enabled" : "disabled";
}</pre>
      </div>

      <p>Поскольку <tt>@ISA</tt> является массивом, ничто не запрещает нам реализовать на PERLе <em>множественное наследование</em>
        классов, т.&nbsp;е. создать класс, который является потомком сразу нескольких классов. Множественное наследование&nbsp;&#151;
        это большая тема, требующая отдельного рассмотрения, поэтому мы ее здесь касаться не будем.</p>

      <h3><a name="ref686">6.8.6. Класс UNIVERSAL</a></h3>

      <p>Истинные ценители PERLа считают, что вся прелесть этого языка в его умолчаниях, и потому пишут на нем так, чтобы непосвященный
        ничего не понял. Даже не разделяя этого подхода, следует признать, что знание умолчаний PERLа часто является полезным. Одним из таких
        полезных действий по умолчанию является следующее: PERL всегда неявно добавляет в конец массива <tt>@ISA</tt> имя модуля UNIVERSAL.
        Иными словами, все классы PERLа наследуют методы класса UNIVERSAL. Таких методов три: <tt><a href="#mcan">can</a></tt>, <tt><a href="#misa">isa</a></tt> и <tt><a href="#mversion">VERSION</a></tt>.</p>

      <h4><a name="hcan">Метод can</a></h4>

<pre class="syntax"><strong><a name="mcan">Синтаксис</a></strong>: <em>ссылка</em>->can(<em>метод</em>)
<strong>Аргументы</strong>: <em>метод</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: ссылка на подпрограмму</pre>

      <p>Если объект, на который указывает <em>ссылка</em>, имеет заданный <em>метод</em>, то метод <strong>can</strong> возвращает ссылку на этот метод.
        В противном случае он возвращает <strong>undef</strong>. Пример:</p>

      <div class="code">
<pre class="code">$sub = $obj-&gt;can('print');</pre>
      </div>

      <h4><a name="hisa">Метод isa</a></h4>

<pre class="syntax"><strong><a name="misa">Синтаксис</a></strong>: <em>ссылка</em>->isa(<em>класс</em>)
<strong>Аргументы</strong>: <em>класс</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: логическое значение</pre>

      <p>Метод <strong>isa</strong> возвращает истину, если <em>ссылка</em> указывает на <em>класс</em> или его наследника, и ложь в противном
        случае. Пример:</p>

      <div class="code">
<pre class="code">$has_io = $fd-&gt;isa("IO::Handle");</pre>
      </div>

      <h4><a name="hversion">Метод VERSION</a></h4>

<pre class="syntax"><strong><a name="mversion">Синтаксис</a></strong>: <em>ссылка</em>->VERSION(<em>версия</em>?)
<strong>Аргументы</strong>: <em>версия</em>&nbsp;&#151; плавающее выражение
<strong>Результат</strong>: номер версии</pre>

      <p>Метод <strong>VERSION</strong> возвращает значение глобальной переменной <tt>$VERSION</tt> в пакете, на который указывает <em>ссылка</em>. Если задана <em>версия</em>
        и она больше, чем значение переменной <tt>$VERSION</tt>, то программа завершается по фатальной ошибке с соответствующей диагностикой. Примеры:</p>

      <div class="code">
<pre class="code">$his_vers = $obj-&gt;VERSION();
Some_Module-&gt;VERSION(3.0);</pre>
      </div>

      <p>Обычно этот метод явно не вызывается; его вызывает функция <tt>use()</tt> при проверке версии. Для того, чтобы обеспечить проверку версии своего модуля,
        нужно просто добавить в него строку вида</p>

      <div class="code">
<pre class="code">our $VERSION = '1.1';</pre>
      </div>

      <h3><a name="ref687">6.8.7. Безымянные подпрограммы как объекты</a></h3>

      <p>Реализация объектов в виде безымянных ассоциативных массивов, которой мы до сих пор пользовались, не является, разумеется,
        единственно возможной. Здесь приводится альтернативная реализация класса Info::Browser, основанная на <a href="perl06.htm#ref666">безымянных подпрограммах</a>.
        Она несколько сложнее и медленнее, но имеет одно существенное преимущество: данные объекта становятся полностью скрытыми от
        внешнего мира. Новый вариант нашего класса имеет вид:</p>

      <div class="code">
<pre class="code">package Info::Browser;
use strict;

my $Count = 0;

sub new {
  my $proto = shift;
  my $class = ref($proto) || $proto;
  $Count++;
  my $self = { NAME => undef, VERSION => undef, OPTIONS => []};
  my $closure = sub {
    my $field = shift;
    if (@_) { $self->{$field} = shift }
    return $self->{$field};
  };
  bless($closure, $class);
}
sub DESTROY {
  $Count--;
}
sub total {
  return $Count;
}
sub name    { &amp;{$_[0]}("NAME", @_[1..$#_]) }
sub version { &amp;{$_[0]}("VERSION", @_[1..$#_]) }
sub options { &amp;{$_[0]}("OPTIONS", [@_[1..$#_]]) }
sub showObject {
  my $self = shift;
  printf "%s %d : ", $self->name, $self->version;
  printf "Java %s, ", $self->options->[0] ? "enabled" : "disabled";
  printf "Cookies %s.\n", $self->options->[1] ? "enabled" : "disabled";
}

1;</pre>
      </div>

      <p>Теперь объект, возвращаемый методом <tt>new()</tt>, это не ссылка на структуру данных, а ссылка на
        безымянную подпрограмму, которая имеет доступ к данным объекта через локальную переменную <tt>$self</tt>.
        Самое интересное, что программу, которая пользуется этим классом, изменять не нужно.</p>

      <h3><a name="ref688">6.8.8. Связывание переменных</a></h3>

      <p>Очень интересной возможностью языка PERL является <em>связывание переменных с объектами</em>. Суть этого явления состоит
        в том, чтобы скрыть реализацию объекта за переменной. Мы можем читать и изменять значение связанной переменной обычным образом,
        но при этом неявно будут вызываться соответствующие методы объекта, которые могут быть сколь угодно сложными.</p>

      <p>Для того, чтобы использовать связывание, мы должны оформить свой класс специальным образом. Это оформление зависит
        от типа связываемой переменной (скаляр, массив, ассоциативный массив, ссылка или описатель файла). Дистрибутив PERL содержит
        соответствующие базовые классы Tie::Scalar, Tie::Array и пр., облегчающие создание связываемых классов. Здесь мы
        приведем пример только связывания скалярной переменной; для других типов техника будет аналогичной.</p>
      <p>Наш пример OutFile скрывает за связанной переменной запись в текстовый файл. При связывании переменной с классом OutFile
        вызывается его конструктор, который создает файл с заданным именем. При удалении связи этот файл закрывается.
        При каждом присваивании связанной переменной нового значения это значение выводится в файл как новая строка.
        Соответствующий пакет OutFile.pm будет иметь вид:</p>

      <div class="code">
<pre class="code">package OutFile;

# Конструктор класса
sub TIESCALAR {
  my $class = shift;
  my $filename = shift;
  open(OUT, ">$filename") or die "Cannot create $filename: $!\n";
  bless {FileHandle => OUT, Value => 0}, $class;
}

# Чтение значения связанной переменной
sub FETCH {
  my $self = shift;
  return $self->{Value};
}

# Задание нового значения связанной переменной
sub STORE {
  my $self = shift;
  my $value = shift;
  my $handle = $self->{FileHandle};
  print $handle "$value\n";
  $self->{Value} = $value;
}

# Деструктор класса
sub DESTROY {
  my $self = shift;
  my $handle = $self->{FileHandle};
  close $handle;
}

1;</pre>
      </div>

      <p>Теперь мы можем написать программу, использующую класс OutFile. Для этого нам потребуются встроенные функции
        PERL, создающие и удаляющие связь переменных с объектами. Существуют три функции работы со связанными переменными:
        <tt>tie()</tt>, <tt>tied()</tt> и <tt>untie()</tt>.</p>

      <p>Функция <tt>tie</tt> устанавливает связь переменной с классом. Она имеет вид</p>

<pre class="syntax"><a name="ftie"></a>tie <em>var</em>, <em>class</em>, <em>arguments</em></pre>

      <p>Эта функция связывает переменую <tt><em>var</em></tt> с классом <tt><em>class</em></tt>. При этом вызывается конструктор
      класса, которому передается список аргументов <tt><em>arguments</em></tt>. Результатом функции является ссылка на созданный
      объект. В дальнейшем мы можем получить эту ссылку в любой момент вызовом функции</p>

<pre class="syntax"><a name="ftied"></a>tied <em>var</em></pre>

      <p>(Если функции <tt>tied</tt> передана несвязанная переменная, то она возвращает неопределенное значение.)
      Для разрыва связи переменной с объектом используется функция </p>

<pre class="syntax"><a name="funtie"></a>untie <em>var</em></pre>

      <p>При разрыве связи неявно вызывает деструктор объекта, связанного с переменной.</p>
      
      <p>Теперь мы можем написать пример использования переменной, связанной с классом OutFile:</p>

      <div class="code">
<pre class="code">use OutFile;

my $test;
tie $test, 'OutFile', 'myfile.txt';
$test = 'First';
$test = 'Second';
$test = 'Third';
untie $test;</pre>
      </div>

      <p>Выполнив эту программу, мы найдем в текущем каталоге новый файл MYFILE.TXT, содержащий следующие строки:</p>
<samp>First<br>
Second<br>
Third</samp>

      <p>Чаще всего связывание переменных используется для установления неявной связи ассоциативных массивов с базами данных,
        но эта тема выходит за пределы нашего справочника.</p>

    </td></tr>
  <tr><td><div id="divFooter"></div></td></tr>
</table>
</body>
</html>
