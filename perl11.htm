<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Author" content="Юрий Лукач">
<meta name="Description" content="Справочник Веб-разработчика: современные технологии WWW">
<meta name="Keywords" content="WWW, Веб, разработка, программирование, HTML, DHTML, CSS, Java, JavaScript, CGI, PERL, ASP, XML, XSL, VML, VRML">
<title>WDH: PERL - Ввод-вывод, файлы и каталоги</title>
<link rel="Prev" href="perl10.htm" title="Встроенные функции (продолжение)">
<link rel="Next" href="perl12.htm" title="Процессы и сокеты">
<link rel="Copyright" href="cpyright.htm" title="Сведения об авторских правах">
<link rev="Made" href="mailto:yury@suncloud.ru" title="Обратная связь">
<script type="text/javascript" src="global/load.js"></script>
<script type="text/javascript" src="global/link.js"></script>
</head>

<body onLoad="initDoc(); addBanner(true)">
<table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin: 0">
  <tr><td><div id="divHeader"></div></td></tr>
  <tr><td id="tdBanner" style="text-align: center"><script type="text/javascript">addBanner(false);</script></td></tr>
  <tr><td>

      <h2><a name="ref611">Глава 6.11. Ввод-вывод, файлы и каталоги</a></h2>

      <h3><a name="ref6111">6.11.1. Функции ввода-вывода</a></h3>

      <p>Все описанные в этом разделе функции оперируют с описателями файлов (см. <a href="perl02.htm#ref6211">п. 6.2.11</a>).
        Обратите внимание, что PERL поддерживает два уровня ввода-вывода. Ввод-вывод низкого уровня (без буферизации данных)
        реализован функциями <tt><a href="#fsysread">sysread</a></tt>, <tt><a href="#fsyswrite">syswrite</a></tt> и
        <tt><a href="#fsysseek">sysseek</a></tt>. Остальные функции ввода-вывода используют внутреннюю буферизацию файлов для
        ускорения операций чтения и записи и не совместимы с функциями низкого уровня. Иными словами, для каждого открытого нами
        файла мы должны использовать только одну группу операций: либо буферизованных, либо нет. Смешение функций из этих групп
        может привести к потере данных.</p>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Функция</th>
            <th>Описание</th>
          </tr>
          <tr>
            <td><a href="#fbinmode"><tt>binmode</tt></a></td>
            <td>Задает двоичный/текстовый режим ввода-вывода.</td>
          </tr>
          <tr>
            <td><a href="#fclose"><tt>close</tt></a></td>
            <td>Закрывает файл.</td>
          </tr>
          <tr>
            <td><a href="#feof"><tt>eof</tt></a></td>
            <td>Проверяет, достигнут ли конец файла.</td>
          </tr>
          <tr>
            <td><a href="#ffileno"><tt>fileno</tt></a></td>
            <td>Возвращает дескриптор открытого файла.</td>
          </tr>
          <tr>
            <td><a href="#fflock"><tt>flock</tt></a></td>
            <td>Блокирует/разблокирует файл.</td>
          </tr>
          <tr>
            <td><a href="#fgetc"><tt>getc</tt></a></td>
            <td>Читает один символ из файла.</td>
          </tr>
          <tr>
            <td><a href="#fioctl"><tt>ioctl</tt></a></td>
            <td>Операции управления вводом-выводом.</td>
          </tr>
          <tr>
            <td><a href="#fopen"><tt>open</tt></a></td>
            <td>Открывает заданный файл.</td>
          </tr>
          <tr>
            <td><a href="#fprint"><tt>print</tt></a></td>
            <td>Выводит в файл строку или список строк.</td>
          </tr>
          <tr>
            <td><a href="#fread"><tt>read</tt></a></td>
            <td>Читает блок данных из файла.</td>
          </tr>
          <tr>
            <td><a href="#freadline"><tt>readline</tt></a></td>
            <td>Читает очередную запись из файла.</td>
          </tr>
          <tr>
            <td><a href="#fseek"><tt>seek</tt></a></td>
            <td>Изменяет текущую позицию в файле.</td>
          </tr>
          <tr>
            <td><a href="#fselect"><tt>select</tt></a></td>
            <td>Задает или возвращает указатель файла вывода по умолчанию.</td>
          </tr>
          <tr>
            <td><a href="#fsysopen"><tt>sysopen</tt></a></td>
            <td>Открывает заданный файл.</td>
          </tr>
          <tr>
            <td><a href="#fsysread"><tt>sysread</tt></a></td>
            <td>Читает блок данных из файла.</td>
          </tr>
          <tr>
            <td><a href="#fsysseek"><tt>sysseek</tt></a></td>
            <td>Изменяет текущую позицию в файле.</td>
          </tr>
          <tr>
            <td><a href="#fsyswrite"><tt>syswrite</tt></a></td>
            <td>Выводит блок данных в файл.</td>
          </tr>
          <tr>
            <td><a href="#ftell"><tt>tell</tt></a></td>
            <td>Возвращает текущую позицию в файле.</td>
          </tr>
          <tr>
            <td><a href="#ftruncate"><tt>truncate</tt></a></td>
            <td>Изменяет длину заданного файла.</td>
          </tr>
        </table>
      </div>

      <h4 class="vindent"><a name="hbinmode">Функция binmode</a></h4>

<pre class="syntax"><strong><a name="fbinmode">Синтаксис</a></strong>: binmode <em>файл</em>, <em>режим</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>режим</em>&nbsp;&#151; строковое выражение</pre>

      <p>Функция <strong>binmode</strong> задает двоичный или текстовый режим ввода-вывода для указанного <em>файла</em>.
        <em>Режим</em> задается строкой <tt>":raw"</tt> для двоичного режима и <tt>":crlf"</tt> для текстового режима. Если этот
        аргумент опущен, то задается двоичный режим. Данная функция должна вызываться после <a href="#fopen">открытия файла</a>,
        но до всех операций ввода или вывода с этим файлом.</p>

      <p>Разные платформы вкладывают разное содержание в понятия "текстовый файл" и "двоичный файл". В частности, в Unix эти понятия
        не различаются, а в DOS и Windows текстовые файлы имеют следующие особенности:</p>
      <ul>
        <li>При чтении текстового файла разделитель строк <tt>"\r\n"</tt> заменяется на <tt>"\n"</tt>, а при записи выполняется обратное преобразование.</li>
        <li>Символ <tt>"\cZ"</tt> при чтении текстового файла воспринимается как конец файла, независимо от того, что хранится после него.</li>
      </ul>

      <p>В целях совместимости  рекомендуется вызывать <strong>binmode</strong> для двоичных файлов и не вызывать для текстовых. Пример:</p>
      
      <div class="code">
<pre class="code">open BINFILE, "myfile.dat" or die "Cannot open file: $!\n";
binmode BINFILE;
  . . .
close BINFILE;</pre>
      </div>

      <h4><a name="hclose">Функция close</a></h4>

<pre class="syntax"><strong><a name="fclose">Синтаксис</a></strong>: close <em>файл</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>eof</strong> закрывает указанный <em>файл</em>. Она возвращает истину, если сброс файловых буферов
        на диск и закрытие файла прошли успешно, и ложь в противном случае. Если аргумент опущен, то закрывается файл,
        принятый по умолчанию для вывода (см. описание функции <a href="#fselect"><tt>select</tt></a>).</p>

      <p>Если <em>файл</em> был открыт с перенаправлением вывода, то функция <strong>close</strong> дожидается завершения работы
        конвейера и возвращает результат его работы. Пример:</p>

      <div class="code">
<pre class="code">open(OUTPUT, '|sort &gt;temp.tmp') or die "Can't start sort: $!";
  . . . # выводим данные в OUTPUT
close OUTPUT or warn $! ? "Error closing sort pipe: $!" : "Exit status $? from sort";
open(INPUT, 'temp.tmp') or die "Can't open 'temp.tmp' for input: $!";</pre>
      </div>

      <h4><a name="heof">Функция eof</a></h4>

<pre class="syntax"><strong><a name="feof">Синтаксис</a></strong>: eof <em>файл</em>?
           eof()
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>eof</strong> возвращает 1, если следующее чтение <em>файла</em> обнаружит конец файла
        или если данный файл не был открыт. В противном случае возвращается 0. Если аргумент опущен, то проверяется
        файл, из которого производилась последняя операция чтения.</p>

      <p>Функция <strong>eof()</strong> имеет особое назначение. Она относится к псевдофайлу, образованному списком файлов,
        указанных в командной строке программы, и проверяет наличие входных записей в нем. Подробнее об этом см. описание
        <a href="perl02.htm#nullread">операции &lt;&gt;</a>.</p>

      <p>Данная функция используется редко, поскольку все функции ввода PERL возвращают <strong>undef</strong>
        при достижении конца файла или ошибке чтения.</p>

      <h4><a name="hfileno">Функция fileno</a></h4>

<pre class="syntax"><strong><a name="ffileno">Синтаксис</a></strong>: fileno <em>файл</em>
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>fileno</strong> возвращает системный дескриптор <em>файла</em> или <strong>undef</strong>,
        если данный файл не был открыт. Обычно она используется в программах, взаимодействующих с функциями, написанными на C.
        Кроме того, с ее помощью можно проверить, указывают ли два описателя на один и тот же файл:</p>

      <div class="code">
<pre class="code">if (fileno(FILE1) == fileno(FILE2)) {
  . . .
}</pre>
      </div>

      <h4><a name="hflock">Функция flock</a></h4>

<pre class="syntax"><strong><a name="fflock">Синтаксис</a></strong>: flock <em>файл</em>, <em>операция</em>
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>операция</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>flock</strong> выполняет заданную <em>операцию</em> блокировки/разблокировки над <em>файлом</em>
        и возвращает истину в случае успеха и ложь при неудаче. <em>Операция</em> задается числом или символической константой
        из модуля Fcntl (нужна директива <code>use Fcntl ':flock'</code>):</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Символическое имя</th>
            <th>Число</th>
            <th>Операция</th>
          </tr>
          <tr>
            <td><tt>LOCK_SH</tt></td>
            <td>1</td>
            <td>Разделяемая блокировка файла.</td>
          </tr>
          <tr>
            <td><tt>LOCK_EX</tt></td>
            <td>2</td>
            <td>Монопольная блокировка файла.</td>
          </tr>
          <tr>
            <td><tt>LOCK_NB</tt></td>
            <td>4</td>
            <td>Не ждать завершения операции блокировки.</td>
          </tr>
          <tr>
            <td><tt>LOCK_UN</tt></td>
            <td>8</td>
            <td>Снятие блокировки файла.</td>
          </tr>
        </table>
      </div>

      <p>Флаг LOCK_NB употребляется в сочетании с LOCK_SH или LOCK_EX. Если его нет, то функция ждет, пока файл
        не будет заблокирован; если он установлен, то возврат из функции производится без ожидания (в этом случае мы
        должны обязательно проверить возвращаемый результат).</p>

      <p>В Windows 95/98 эта функция не реализована (вызывает фатальную ошибку). Пример:</p>

      <div class="code">
<pre class="code">use Fcntl ':flock';

open(MYFILE, ">test.txt") or die "Can't create file: $!";
flock(MYFILE, LOCK_EX);
print MYFILE $msg, "\n";
flock(MYFILE, LOCK_UN);</pre>
      </div>

      <h4><a name="hgetc">Функция getc</a></h4>

<pre class="syntax"><strong><a name="fgetc">Синтаксис</a></strong>: getc <em>файл</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>getc</strong> читает очередной символ из <em>файла</em> или из STDIN, если аргумент опущен.
        Если STDIN&nbsp;&#151; это клавиатура, то она ждет нажатия клавиши.</p>

      <h4><a name="hioctl">Функция ioctl</a></h4>

<pre class="syntax"><strong><a name="fioctl">Синтаксис</a></strong>: ioctl <em>файл</em>, <em>операция</em>, <em>параметр</em>
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>операция</em>&nbsp;&#151; числовое выражение
           <em>параметр</em>&nbsp;&#151; скалярное выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>ioctl</strong> системно-зависима. В Unix она вызывает стандартную функцию C <tt>ioctl</tt>, предназначенную для
        управления устройствами ввода-вывода, а в Windows используется только для сокетов и вызывает функцию <tt>ioctlsocket</tt>, реализованную
        в Winsock API. Мы не приводим здесь описания этих системных функций, см. документацию на соответствующие операционные системы.</p>

      <h4><a name="hopen">Функция open</a></h4>

<pre class="syntax"><strong><a name="fopen">Синтаксис</a></strong>: open <em>файл</em>, <em>режим</em>, <em>имя</em>
           open <em>файл</em>, <em>имя</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>режим, имя</em>&nbsp;&#151; строковые выражения
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>open</strong> выполняет открытие файлов в стиле командного интерпретатора Unix. <em>Имя</em>
        задает имя открываемого файла. В случае успешного открытия файла его описатель заносится в переменную <em>файл</em>
        и возвращается ненулевое значение. При неудаче возвращается значение <strong>undef</strong>. Если <em>имя</em> опущено,
        то PERL считает, что имя файла хранится в скалярной переменной с тем же именем, что и <em>файл</em>, например:</p>

      <div class="code">
<pre class="code">open(MYFILE, 'test.txt'); # открываем TEXT.TXT

$MYFILE = 'test.txt';
open(MYFILE);             # то же самое</pre>
      </div>

      <p>Эта функция имеет два формата. В первом формате параметр <em>режим</em> содержит режим открытия файла, а параметр <em>имя</em>&nbsp;&#151; имя файла.
      Во втором формате параметр <em>имя</em> содержит и имя файла, и необязательный режим его открытия (сначала режим, затем имя, между ними
      допустимы пробелы); при этом начальные и конечные пробелы из имени файла удаляются перед его открытием. Режим открытия файла задается следующим образом:</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Обозначение</th>
            <th>Режим открытия файла</th>
          </tr>
          <tr>
            <td><tt>'&lt;'</tt> или пусто</td>
            <td>Открывает существующий файл для чтения. Если такого файла нет, возвращает ошибку.</td>
          </tr>
          <tr>
            <td><tt>'&gt;'</tt></td>
            <td>Открывает новый файл для записи. Если такой файл есть, его содержимое удаляется.</td>
          </tr>
          <tr>
            <td><tt>'&gt;&gt;'</tt></td>
            <td>Открывает файл для дозаписи в его конец. Если такого файла нет, то он создается.</td>
          </tr>
          <tr>
            <td><tt>'+&lt;'</tt></td>
            <td>Открывает существующий файл для чтения и записи. Если такого файла нет, возвращает ошибку.</td>
          </tr>
          <tr>
            <td><tt>'+&gt;'</tt></td>
            <td>Открывает новый файл для чтения и записи. Если такой файл есть, его содержимое удаляется.</td>
          </tr>
          <tr>
            <td><tt>'+&gt;&gt;'</tt></td>
            <td>Открывает файл для чтения и дозаписи в его конец. Если такого файла нет, то он создается.</td>
          </tr>
          <tr>
            <td><tt>'|-'</tt></td>
            <td>Имя файла задает программу, на стандартный ввод которой будет перенаправлен вывод в этот файл (только в Unix).</td>
          </tr>
          <tr>
            <td><tt>'-|'</tt></td>
            <td>Имя файла задает программу, стандартный вывод которой будет перенаправлен на чтение из этого файла (только в Unix).</td>
          </tr>
        </table>
      </div>

      <p>В Windows для создания конвейеров следует использовать альтернативный синтаксис: второй формат функции <strong>open</strong>,
        в  которой имя файла начинается с символа '|' (эквивалентно режиму '|-') или заканчивается символом '|'  (эквивалентно режиму '-|').</p>
        
      <p>Во втором формате команды после режимов '&gt;', '&gt;&gt;', '&lt;', '+&gt;', '+&gt;&gt;', '+&lt;' можно добавить символ '&amp;'. В этом
        случае остаток строки интерпретируется как имя описателя файла, если это строка, или дескриптор файла, если это число.
         Этот синтаксис следует традиции командного интерпретатора Bourne и позволяет нам дублировать описатели открытых файлов.
         Кроме того, в этом формате поддержаны два полезных сокращения: имя файла '-' указывает на STDIN, а '>-'&nbsp;&#151; на STDOUT. Примеры:</p>

      <div class="code">
<pre class="code">open(MYFILE, 'input.txt');       # открывает файл для чтения
open(LOG, '&gt;&gt;mylog');            # открывает протокол для дозаписи
open(DBASE, '+&lt;', 'data.dbf');   # открывает БД для обновления
open(DBASE, '+&lt;data.dbf');       # то же самое
open(SORTED, "|sort &gt;temp.tmp"); # сортировка результатов записи в файл
open(OUT, "&gt;&amp;STDOUT");           # открывает копию STDOUT

open(F, '-|', "cat -n '$file'"); # открывает $file на чтение в Unix
open(F, "cat -n '$file'|");      # то же самое</pre>
      </div>

      <h4><a name="hprint">Функция print</a></h4>

<pre class="syntax"><strong><a name="fprint">Синтаксис</a></strong>: print <em>файл</em>, <em>список</em>
           print <em>список</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>список</em>&nbsp;&#151; список выражений</pre>

      <p>Функция <strong>print</strong> выводит <em>список</em> строк (в частности, одну строку) в заданный <em>файл</em>.
        Если аргумент <em>файл</em> опущен, то вывод производится в файл, принятый по умолчанию для вывода (см. описание функции <a href="#fselect"><tt>select</tt></a>).
        Если и <em>список</em> опущен, то выводится содержимое специальной переменной <tt>$_</tt>. Если значение переменной <tt>$,</tt> не пусто,
        то оно выводится между элементами <em>списка</em>. Если значение переменной <tt>$\</tt> не пусто, то оно выводится после вывода <em>списка</em>.
        Обратите внимание, что если даже вы передаете этой функции одно выражение для вывода, оно вычисляется в контексте списка.
        Если <em>файл</em> задается выражением, то вам придется указать блок, который возвращает значение описателя файла. Примеры:</p>
      
      <div class="code">
<pre class="code">@a = (1, 2, 3);
print @a;      # выводит на STDOUT строку '123'
print 1, 2, 3; # то же самое

$, = ' ';
print MYFILE 'aaa', 'bbb', 'ccc'; # выводит в MYFILE строку 'aaa bbb ccc'

print { $OK ? STDOUT : STDERR } "$message\n";</pre>
      </div>

      <h4><a name="hread">Функция read</a></h4>

<pre class="syntax"><strong><a name="fread">Синтаксис</a></strong>: read <em>файл</em>, <em>скаляр</em>, <em>длина</em>, <em>смещение</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>скаляр</em>&nbsp;&#151; имя скалярной переменной
           <em>длина</em>, <em>смещение</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>read</strong> пытается считать из заданного <em>файла</em> количество байтов, заданное аргументом <em>длина</em>. Результат чтения
        заносится в переменную <em>скаляр</em> как строка байтов. Если задан аргумент <em>смещение</em>, то результат заносится в <em>скаляр</em>
        как в строку, начиная с ее байта с заданным смещением (отрицательное смещение отсчитывается от конца строки). Эта функция возвращает количество
        фактически считанных байтов, 0 при попытке чтения в конце файла и <strong>undef</strong> при ошибке чтения. Пример: допустим, что наш файл TEST.DAT
        начинается с символов <tt>abcdef</tt>. Тогда сценарий</p>
      
      <div class="code">
<pre class="code">open F, 'test.dat';
read F, $x, 5;
print $x;</pre>
      </div>

      <p class="noindent">выведет на экран строку <samp>abcde</samp>.</p>

      <h4><a name="hreadline">Функция readline</a></h4>

<pre class="syntax"><strong><a name="freadline">Синтаксис</a></strong>: readline <em>файл</em>
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; typeglob описателя файла
<strong>Результат</strong>: строковое значение или список строк</pre>

      <p>Функция <strong>readline</strong> читает файл с заданным typeglob. В скалярном контексте она считывает
        очередную запись файла и возвращает ее. В контексте списка она читает файл до конца и возвращает список записей.
        Ограничитель входных записей задается значением специальной переменной <tt>$/</tt>. Это внутренняя функция PERLа,
        реализующая <a href="perl02.htm#fileread">операцию &lt;<em>описатель</em>&gt;</a>, однако вы можете вызывать ее и
        непосредственно. Например, следующие два оператора эквивалентны:</p>
      
      <div class="code">
<pre class="code">$line = &lt;STDIN&gt;;
$line = readline(*STDIN);</pre>
      </div>

      <h4><a name="hseek">Функция seek</a></h4>

<pre class="syntax"><strong><a name="fseek">Синтаксис</a></strong>: seek <em>файл</em>, <em>смещение</em>, <em>начало</em>
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>смещение</em>, <em>начало</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>seek</strong> изменяет текущую позицию в заданном <em>файле</em> и возвращает 1 в случае успеха и 0 при неудаче.
        Новая позиция вычисляется на основании параметров <em>начало</em> и <em>смещение</em> в соответствии со следующей таблицей:</p>
      
      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th colspan="2"><em>начало</em></th>
            <th rowspan="2">Новая позиция</th>
          </tr>
          <tr>
            <th>Имя</th>
            <th>Значение</th>
          </tr>
          <tr>
            <td><tt>SEEK_SET</tt></td>
            <td align="center">0</td>
            <td><em>смещение</em> относительно начала файла</td>
          </tr>
          <tr>
            <td><tt>SEEK_CUR</tt></td>
            <td align="center">1</td>
            <td>текущая позиция + <em>смещение</em></td>
          </tr>
          <tr>
            <td><tt>SEEK_END</tt></td>
            <td align="center">2</td>
            <td>конец файла + <em>смещение</em> (обычно отрицательное)</td>
          </tr>
        </table>
      </div>

      <p>Для использования символических имен параметра <em>начало</em> мы должны добавить в наш сценарий
        директиву <code>use Fcntl ':seek'</code>. Примеры:</p>

      <div class="code">
<pre class="code">use Fcntl ':seek';
seek(FILE, 0, 2);        # позиционируемся на конец файла
seek(FILE, 0, SEEK_END); # то же самое</pre>
      </div>
      
      <p>Функцию <strong>seek</strong> не следует использовать совместно с <tt><a href="#fsysread">sysread</a></tt> и
        <tt><a href="#fsyswrite">syswrite</a></tt> из-за проблем, связанных с внутренней буферизацией ввода-вывода.
        В этому случае следует пользоваться функцией <tt><a href="#fsysseek">sysseek</a></tt>.</p>

      <h4><a name="hselect">Функция select</a></h4>

<pre class="syntax"><strong><a name="fselect">Синтаксис</a></strong>: select <em>файл</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
<strong>Результат</strong>: описатель файла</pre>

      <p>Функция <strong>select</strong> возвращает указатель файла, принятый по умолчанию для вывода. Если параметр <em>файл</em>
        задан, то он становится новым файлом, принятым для вывода по умолчанию. После этого функции <tt><a href="#fprint">print</a></tt>
        и <tt><a href="#fwrite">write</a></tt> без указания файла вывода будут производить запись в этот файл. Кроме того, специальные
        переменные, связанные с выводом, теперь будут относиться к этому файлу. Первоначально для вывода по умолчанию принят STDOUT.
        Следующий пример делает текущим каналом вывода файл REPORT и устанавливает длину страницы вывода для него равной 70 строкам:</p>
      
      <div class="code">
<pre class="code">select(REPORT); $= = 70;</pre>
      </div>

      <p>Приведем еще один пример, показывающий, как включить автоматический сброс на диск буферов файла STDERR:</p>
      
      <div class="code">
<pre class="code">$old = select(STDERR); $| = 1; select($old);</pre>
      </div>

      <h4><a name="hsysopen">Функция sysopen</a></h4>

<pre class="syntax"><strong><a name="fsysopen">Синтаксис</a></strong>: sysopen <em>файл</em>, <em>имя</em>, <em>режим</em>, <em>права</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>имя</em>&nbsp;&#151; строковое выражение
           <em>режим, доступ</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>sysopen</strong> выполняет открытие файлов в стиле языка C. <em>Имя</em> задает имя открываемого файла.
        В случае успешного открытия файла его описатель заносится в переменную <em>файл</em> и возвращается ненулевое значение.
        При неудаче возвращается значение <strong>undef</strong>.</p>
      <p>Аргумент <em>режим</em>&nbsp;&#151; это набор битовых флагов, задающий режим открытия файла. Поскольку числовые значения флагов
        системно-зависимы, следует всегда пользоваться их символическими именами. Для доступа к этим именам необходимо включить в
        сценарий директиву <code>use Fcntl</code>. Перечислим имена флагов режима открытия файла, которые есть и в Unix, и в Windows:</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Имя</th>
            <th>Значение</th>
          </tr>
          <tr>
            <td><tt>O_APPEND</tt></td>
            <td>Перемещает указатель файла в его конец перед каждой операцией записи.</td>
          </tr>
          <tr>
            <td><tt>O_BINARY</tt></td>
            <td>Открывает файл в двоичном режиме (см. описание функции <tt><a href="#fbinmode">binmode</a></tt>).</td>
          </tr>
          <tr>
            <td><tt>O_CREAT</tt></td>
            <td>Создает новый файл и открывает его для записи. Если такой файл уже есть, не выполняет никаких действий.</td>
          </tr>
          <tr>
            <td><tt>O_EXCL</tt></td>
            <td>Возвращает ошибку, если файл с таким именем существует. Употребляется только с флагом <tt>O_CREAT</tt>.
              Этот флаг сильнее, чем флаг <tt>O_TRUNC</tt>.</td>
          </tr>
          <tr>
            <td><tt>O_RANDOM</tt></td>
            <td>Открывает файл в режиме произвольного доступа.</td>
          </tr>
          <tr>
            <td><tt>O_RDONLY</tt></td>
            <td>Открывает файл только для чтения. Не может сочетаться с флагами <tt>O_RDWR</tt> и <tt>O_WRONLY</tt>.</td>
          </tr>
          <tr>
            <td><tt>O_RDWR</tt></td>
            <td>Открывает файл для чтения и записи. Не может сочетаться с флагами <tt>O_RDONLY</tt> и <tt>O_WRONLY</tt>.</td>
          </tr>
          <tr>
            <td><tt>O_SEQUENTIAL</tt></td>
            <td>Открывает файл в режиме последовательного доступа.</td>
          </tr>
          <tr>
            <td><tt>O_TEMPORARY</tt></td>
            <td>Создает временный файл, который будет удален после закрытия последнего указателя на него.
              Употребляется только с флагом <tt>O_CREAT</tt>.</td>
          </tr>
          <tr>
            <td><tt>O_TEXT</tt></td>
            <td>Открывает файл в текстовом режиме (см. описание функции <tt><a href="#fbinmode">binmode</a></tt>).</td>
          </tr>
          <tr>
            <td><tt>O_TRUNC</tt></td>
            <td>Открывает файл и удаляет его содержимое, сбрасывая длину файла в нуль; файл должен быть доступен для записи.
              Не может сочетаться с флагом <tt>O_RDONLY</tt>. Вместе с флагом <tt>O_CREAT</tt> создает новый файл, даже если такой файл уже есть.</td>
          </tr>
          <tr>
            <td><tt>O_WRONLY</tt></td>
            <td>Открывает файл только для записи. Не может сочетаться с флагами <tt>O_RDWR</tt> и <tt>O_RDONLY</tt>.</td>
          </tr>
        </table>
      </div>

      <p>Если режим содержит флаг <tt>O_CREAT</tt>, т.&nbsp;е. если создается новый файл, то мы можем указать аргумент <em>права</em>.
        Он задает маску прав доступа к файлу, которая будет установлена при первом закрытии нового файла. Формат этой маски приведен в описании
        функции <a href="perl12.htm#fumask"><tt>umask</tt></a>. По умолчанию она равна восьмеричному числу 0666; это означает, что созданный файл
        будет доступен для чтения и записи. Примеры:</p>

      <div class="code">
<pre class="code">use Fcntl;
# Открываем существующий фал для чтения
sysopen IN, 'data.txt', O_RDONLY;
# Создаем новый файл. Если он уже есть, то фатальная ошибка.
sysopen OUT, 'data.txt', O_CREAT | O_EXCL or die "Такой файл уже есть!";
# Создаем новый файл. Если он уже есть, то его содержимое теряется.
sysopen OUT, 'data.txt', O_CREAT | O_TRUNC;</pre>
      </div>

      <h4><a name="hsysread">Функция sysread</a></h4>

<pre class="syntax"><strong><a name="fsysread">Синтаксис</a></strong>: sysread <em>файл</em>, <em>скаляр</em>, <em>длина</em>, <em>смещение</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>скаляр</em>&nbsp;&#151; имя скалярной переменной
           <em>длина</em>, <em>смещение</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>sysread</strong> пытается считать из заданного <em>файла</em> количество байтов, заданное аргументом <em>длина</em>. Результат чтения
        заносится в переменную <em>скаляр</em> как строка байтов. Если задан аргумент <em>смещение</em>, то результат заносится в <em>скаляр</em>
        как в строку, начиная с ее байта с заданным смещением (отрицательное смещение отсчитывается от конца строки). Результат равен количеству фактически
        считанных байтов, 0 при попытке чтения в конце файла и <strong>undef</strong> при ошибке чтения.</p>

      <p>Эта функция полностью аналогична функции <tt><a href="#fread">read</a></tt>, но с одним важным отличием: чтение производится без
        внутренней буферизации данных. Поэтому ее нельзя смешивать с функциями <tt><a href="#fread">read</a></tt>, <tt><a href="#fprint">print</a></tt>,
        <tt><a href="#fwrite">write</a></tt>, <tt><a href="#fseek">seek</a></tt>, <tt><a href="#ftell">tell</a></tt>, <tt><a href="#feof">eof</a></tt>
        и т.&nbsp;п. В действительности, эта функция полезна только при чтении данных с последовательных устройств типа терминалов.</p>

      <h4><a name="hsysseek">Функция sysseek</a></h4>

<pre class="syntax"><strong><a name="fsysseek">Синтаксис</a></strong>: sysseek <em>файл</em>, <em>смещение</em>, <em>начало</em>
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>смещение</em>, <em>начало</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>sysseek</strong> изменяет текущую позицию в заданном <em>файле</em> и возвращает 1 в случае успеха и 0 при неудаче.
        Она полностью аналогична функции <tt><a href="#fseek">seek</a></tt>, но с одним важным отличием: позиционирование производится без
        внутренней буферизации данных. Поэтому ее нельзя смешивать с функциями <tt><a href="#fread">read</a></tt>, <tt><a href="#fprint">print</a></tt>,
        <tt><a href="#fwrite">write</a></tt>, <tt><a href="#fseek">seek</a></tt>, <tt><a href="#ftell">tell</a></tt>, <tt><a href="#feof">eof</a></tt>
        и т.&nbsp;п. Использование этой функции допустимо только в сочетании с функциями <tt><a href="#fsysread">sysread</a></tt> и
        <tt><a href="#fsyswrite">syswrite</a></tt>.</p>

      <p>Парной функции <tt>systell</tt> в PERL'e нет. Вместо нее следует использовать <code>sysseek(<em>файл</em>, 0, 1)</code>.</p>

      <h4><a name="hsyswrite">Функция syswrite</a></h4>

<pre class="syntax"><strong><a name="fsyswrite">Синтаксис</a></strong>: syswrite <em>файл</em>, <em>скаляр</em>, <em>длина</em>?, <em>смещение</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>скаляр</em>&nbsp;&#151; имя скалярной переменной
           <em>длина</em>, <em>смещение</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>syswrite</strong> пытается записать в заданный <em>файл</em> количество байтов, заданное аргументом <em>длина</em> из
        переменной <em>скаляр</em> как строку байтов. Если <em>длина</em> не задана, то переменная <em>скаляр</em> выводится в файл <em>полностью</em>.
        Если задан аргумент <em>смещение</em>, то выводятся байты из строки <em>скаляр</em>, начиная с ее байта с заданным смещением (отрицательное
        смещение отсчитывается от конца строки). Результат равен количеству фактически записанных байтов, 0 при попытке чтения в конце файла и
        <strong>undef</strong> при ошибке чтения.</p>

      <p>Эта функция выполняет запись без внутренней буферизации данных. Поэтому ее нельзя смешивать с функциями <tt><a href="#fread">read</a></tt>,
        <tt><a href="#fprint">print</a></tt>, <tt><a href="#fwrite">write</a></tt>, <tt><a href="#fseek">seek</a></tt>, <tt><a href="#ftell">tell</a></tt>,
        <tt><a href="#feof">eof</a></tt> и т.&nbsp;п.</p>

      <h4><a name="htell">Функция tell</a></h4>

<pre class="syntax"><strong><a name="ftell">Синтаксис</a></strong>: tell <em>файл</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>tell</strong> возвращает текущую позицию в заданном <em>файле</em>. Если <em>файл</em> опущен,
        то возвращается текущая позиция в файле, из которого производилось последнее чтение. Пример:</p>

      <div class="code">
<pre class="code">open OUT, '>test.txt';
print OUT 'abc';
$pos = tell OUT;  # $pos равно 3</pre>
      </div>

      <h4><a name="htruncate">Функция truncate</a></h4>

<pre class="syntax"><strong><a name="ftruncate">Синтаксис</a></strong>: truncate <em>файл</em>, <em>длина</em>
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>длина</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>truncate</strong> усекает заданный <em>файл</em> до заданной <em>длины</em>. Она возвращает
        истину в случае успеха и <strong>undef</strong> при неудаче.</p>
      <p>Windows требует, чтобы <em>файл</em> был открыт для дозаписи в конец файла (т.&nbsp;е. либо функцией
        <code><a href="#fopen">open(<em>файл</em>, '&gt;&gt;имя_файла')</a></code>, либо функцией
        <code><a href="#fsysopen">sysopen(<em>файл</em>, 'имя_файла', O_APPEND | O_RDWR)</a></code>).
        Кроме того, для успеха операции требуется, чтобы файл не был открыт другими процессами.</p>

      <h3><a name="ref6112">6.11.2. Форматирование вывода</a></h3>

      <p>PERL поддерживает два механизма форматирования данных для вывода. Первый механизм заимствован из
      языка FORTRAN и основан на шаблонах вывода: функция <tt><a href="#fformat">format</a></tt> задает шаблон вывода,
      а функция <tt><a href="#fwrite">write</a></tt> выводит данные в соответствии с заданным шаблоном.
      Второй механизм заимствован из языка C и реализован функциями <tt><a href="#fprintf">printf</a></tt> и
      <tt><a href="#fsprintf">sprintf</a></tt>, которые выводят данные в файл в соответствии с заданной спецификацией формата.</p>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Функция</th>
            <th>Описание</th>
          </tr>
          <tr>
            <td><a href="#fformat"><tt>format</tt></a></td>
            <td>Декларирует шаблон вывода для <tt><a href="#fwrite">write</a></tt>.</td>
          </tr>
          <tr>
            <td><a href="#fformline"><tt>formline</tt></a></td>
            <td>Форматированный вывод в строку.</td>
          </tr>
          <tr>
            <td><a href="#fprintf"><tt>printf</tt></a></td>
            <td>Форматирует и выводит строку в файл.</td>
          </tr>
          <tr>
            <td><a href="#fsprintf"><tt>sprintf</tt></a></td>
            <td>Форматирует строку.</td>
          </tr>
          <tr>
            <td><a href="#fwrite"><tt>write</tt></a></td>
            <td>Форматированный вывод записи в файл.</td>
          </tr>
        </table>
      </div>

      <h4><a name="hformat">Функция format</a></h4>

<pre class="syntax"><strong><a name="fformat">Синтаксис</a></strong>:
format <em>имя</em> =
<em>шаблон</em>
.</pre>

      <p>Функция <strong>format</strong> декларирует шаблон вывода с заданным <em>именем</em>. Имена шаблонов
        образуют собственное пространство имен; иными словами, функция ABC и шаблон ABC не имеют ничего общего.
        По умолчанию принято, что шаблон вывода для файла с описателем FILE имеет имя FILE. Естественно, что мы
        можем использовать для форматирования вывода в FILE и шаблоны с другими именами.</p>

      <p>Шаблон вывода состоит из строк трех видов:</p>
      <ul>
        <li><em>комментарии</em>, которые начинаются с символа # в первой позиции;</li>
        <li><em>форматные строки</em>, которые задают формат выводимой строки;</li>
        <li><em>строки аргументов</em>, содержащие значения, которые при выводе подставляются в форматные строки.</li>
      </ul>
      <p>Форматные строки выводятся в точности так, как они заданы, за исключением специальных полей, в которые подставляются
        значения, заданные в строках аргументов. Специальные поля начинаются с символа @ или ^. Поля, начинающиеся с символа @,
        могут иметь следующий вид:</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <td><tt>@&lt;&#133;&lt;</tt></td>
            <td>Выводит значение переменной в поле заданной ширины, выравненное влево.</td>
          </tr>
          <tr>
            <td><tt>@&gt;&#133;&gt;</tt></td>
            <td>Выводит значение переменной в поле заданной ширины, выравненное вправо.</td>
          </tr>
          <tr>
            <td><tt>@|&#133;|</tt></td>
            <td>Выводит значение переменной в поле заданной ширины, выравненное по центру.</td>
          </tr>
          <tr>
            <td><tt>@#&#133;#</tt></td>
            <td>Выводит значение числовой переменной в поле заданной ширины, выравненное вправо.</td>
          </tr>
          <tr>
            <td><nobr><tt>@#&#133;#.</tt></nobr></td>
            <td>Выводит значение числовой переменной и десятичную точку в поле заданной ширины, выравненное вправо.</td>
          </tr>
          <tr>
            <td><tt>@*</tt></td>
            <td>Выводит многострочное значение без задания ширины поля.</td>
          </tr>
        </table>
      </div>

      <p>Если выводимая строка не помещается в заданное поле, то она обрезается.</p>
      
      <p>Специальные поля, которые начинаются с символа ^, обрабатываются иначе. Если поле заполнено символом #,
        то в него также выводится числовое значение, но с одной особенностью: если значение неопределено, то поле выводится пустым.
        Для остальных заполнителей (&lt;, &gt; и |) соответствующий аргумент должен быть не выражением, а скалярной переменной,
        содержащей строковое значение. PERL выводит столько символов этой строки, сколько поместится в заданное поле, а затем
        удаляет эту часть строки из аргумента. Затем поле может повториться на следующей строке и т. д., позволяя вывести длинный
        текст в несколько строк. Разбивка строки производится только по тем символам, которые заданы в специальной переменной <tt>$:</tt>.
        При желании можно добавить в конец последнего поля символы "...", чтобы показать, что строка слишком длинна для полного вывода.</p>
      <p>Поля, начинающиеся с символа ^, можно использовать для вывода записей переменной длины. Если исходный текст короток, то
        мы можем подавить вывод пустых строк, помещая в форматные строки символ ~. Если поместить в строку два символа ~ подряд, то
        ее вывод будет повторяться до тех пор, пока все поля в строке не будут исчерпаны.</p>
      <p>Для вывода заголовка на каждой странице отчета следует использовать функцию <tt>format</tt> с именем шаблона, состоящим из
        имени шаблона вывода отчета плюс слово "_TOP".</p>
      <p>Пример: следующая программа</p>

      <div class="code">
<pre class="code">
format MY_TOP =
	Тестовая страница

.
format MY =
Тест: @<<<<<<<< @||||| @>>>>>
      $str,     $x,    '$'.int($num)
.

$str = 'строка';
$x = '1';
$num = 123.456;
$~ = 'MY';
write;
</pre>
      </div>

      <p class=noindent>выведет на консоль такой отчет:</p>

<pre><samp>
	Тестовая страница

Тест: строка      1      $123
</samp></pre>

      <h4><a name="hformline">Функция formline</a></h4>

<pre class="syntax"><strong><a name="fformline">Синтаксис</a></strong>: formline <em>шаблон</em>, <em>список</em>
<strong>Аргументы</strong>: <em>шаблон</em>&nbsp;&#151; имя шаблона
           <em>список</em>&nbsp;&#151; список выражений
<strong>Результат</strong>: логическая истина</pre>

      <p>Это внутренняя функция, используемая функцией <tt><a href="#fwrite">write</a></tt>. Она применяет заданный <em>шаблон</em>
        к заданному <em>списку</em> значений и заносит сформатированный результат в специальную переменную <tt>$^A</tt> (аккумулятор форматного вывода).</p>

      <h4><a name="hprintf">Функция printf</a></h4>

<pre class="syntax"><strong><a name="fprintf">Синтаксис</a></strong>: printf <em>файл</em>? <em>формат</em>, <em>список</em>
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла
           <em>формат</em>&nbsp;&#151; спецификация формата
           <em>список</em>&nbsp;&#151; список выражений</pre>

      <p>Эта функция эквивалентна выражению <code><a href="#fprint">print</a> <em>файл</em> <a href="#fsprintf">sprintf</a>(<em>формат</em>, <em>список</em>)</code> с
        единственным отличием: в конец выводимой строки не добавляется разделитель выходных записей <tt>$\</tt>. Пример:</p>

      <div class="code">
<pre class="code">printf STDOUT "Версия PERL: v%vd\n", $^V; # "Версия PERL: v5.6.0"</pre>
      </div>

      <h4><a name="hsprintf">Функция sprintf</a></h4>

<pre class="syntax"><strong><a name="fsprintf">Синтаксис</a></strong>: sprintf <em>формат</em>, <em>список</em>
<strong>Аргументы</strong>: <em>формат</em>&nbsp;&#151; спецификация формата
           <em>список</em>&nbsp;&#151; список выражений
<strong>Результат</strong>: строковое значение</pre>

      <p>Эта функция выполняет форматирование <em>списка</em> в соответствии с правилами, заданными в строке
        <em>формата</em>, и возвращает полученную таким образом строку. Правила описания форматных строк PERL
        заимствовал практически без изменений из языка C; тем не менее, для полноты описания мы приводим эти правила здесь.</p>

      <p>Форматная строка является комбинацией обычных символов и специальных <em>полей спецификации формата</em>.
        Поле спецификации формата состоит из символа % и латинской буквы, задающей тип преобразования. Между символом
        % и буквой типа могут размещаться уточняющие флаги, описанные ниже. Если после символа % стоит буква, неизвестная
        функции <tt>sprintf</tt>, то символ % игнорируется, а буква воспринимается как обычный символ; в частности,
        для вывода в результирующую строку самого символа % можно использовать поле %%. PERL поддерживает следующие
        типы преобразований:</p>
        
      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Поле</th>
            <th>Аргумент</th>
            <th>Результат</th>
          </tr>
          <tr>
            <td><tt>%c</tt></td>
            <td>Число</td>
            <td>Символ с данным кодом.</td>
          </tr>
          <tr>
            <td><tt>%s</tt></td>
            <td>Строка</td>
            <td>Строка символов.</td>
          </tr>
          <tr>
            <td><tt>%d</tt></td>
            <td>Число</td>
            <td>Целое десятичное число со знаком.</td>
          </tr>
          <tr>
            <td><tt>%u</tt></td>
            <td>Число</td>
            <td>Целое десятичное число без знака.</td>
          </tr>
          <tr>
            <td><tt>%b</tt></td>
            <td>Число</td>
            <td>Целое двоичное число без знака.</td>
          </tr>
          <tr>
            <td><tt>%o</tt></td>
            <td>Число</td>
            <td>Целое восьмеричное число без знака.</td>
          </tr>
          <tr>
            <td><tt>%x</tt></td>
            <td>Число</td>
            <td>Целое шестнадцатеричное число без знака.</td>
          </tr>
          <tr>
            <td><tt>%X</tt></td>
            <td>Число</td>
            <td>То же, но с прописными буквами.</td>
          </tr>
          <tr>
            <td><tt>%e</tt></td>
            <td>Число</td>
            <td>Плавающее число в научной нотации вида [-]1.2345e&plusmn;678.</td>
          </tr>
          <tr>
            <td><tt>%E</tt></td>
            <td>Число</td>
            <td>То же, но с прописным E.</td>
          </tr>
          <tr>
            <td><tt>%f</tt></td>
            <td>Число</td>
            <td>Плавающее число в формате с десятичной точкой вида [-]1234.5678.</td>
          </tr>
          <tr>
            <td><tt>%g</tt></td>
            <td>Число</td>
            <td>Плавающее число в наиболее компактном из форматов <tt>%e</tt> или <tt>%f</tt>.</td>
          </tr>
          <tr>
            <td><tt>%G</tt></td>
            <td>Число</td>
            <td>То же, но <tt>%E</tt> или <tt>%f</tt>.</td>
          </tr>
          <tr>
            <td><tt>%p</tt></td>
            <td>Переменная</td>
            <td>Указатель (шестнадцатеричный адрес переменной).</td>
          </tr>
          <tr>
            <td><tt>%n</tt></td>
            <td>Переменная</td>
            <td>Сохраняет количество символов, выведенных в результирующую строку к этому моменту,
            в следующей переменной списка аргументов.</td>
          </tr>
          <tr>
            <td><tt>%i</tt></td>
            <td>Число</td>
            <td>Устаревший синомим для <tt>%d</tt>.</td>
          </tr>
          <tr>
            <td><tt>%D</tt></td>
            <td>Число</td>
            <td>Устаревший синомим для <tt>%ld</tt>.</td>
          </tr>
          <tr>
            <td><tt>%U</tt></td>
            <td>Число</td>
            <td>Устаревший синомим для <tt>%lu</tt>.</td>
          </tr>
          <tr>
            <td><tt>%O</tt></td>
            <td>Число</td>
            <td>Устаревший синомим для <tt>%lo</tt>.</td>
          </tr>
          <tr>
            <td><tt>%F</tt></td>
            <td>Число</td>
            <td>Устаревший синомим для <tt>%f</tt>.</td>
          </tr>
        </table>
      </div>
      
      <p>Между символом % и буквой типа могут указываться следующие флаги:</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Флаг</th>
            <th>Значение</th>
          </tr>
          <tr>
            <td><em>пробел</em></td>
            <td>Начинать положительные числа с символа пробел.</td>
          </tr>
          <tr>
            <td><tt>+</tt></td>
            <td>Начинать положительные числа с символа +.</td>
          </tr>
          <tr>
            <td><tt>-</tt></td>
            <td>Выравнивание результата по левому краю.</td>
          </tr>
          <tr>
            <td><tt>0</tt></td>
            <td>Использовать нули, а не пробелы, для выравнивания по правому краю.</td>
          </tr>
          <tr>
            <td><tt>#</tt></td>
            <td>Начинать ненулевые восьмеричные числа с "0", ненулевые шестнадцатеричные числа с "0x".</td>
          </tr>
          <tr>
            <td><em>число</em></td>
            <td>Минимальная ширина поля.</td>
          </tr>
          <tr>
            <td><tt>.</tt><em>число</em></td>
            <td>Для плавающих чисел&nbsp;&#151; число знаков после запятой, для строк&nbsp;&#151;
            максимальная длина, для целых чисел&nbsp;&#151; минимальная длина.</td>
          </tr>
          <tr>
            <td><tt>l</tt></td>
            <td>Интрепретировать число как переменную типа <tt>long</tt> или <tt>unsigned long</tt> языка C.</td>
          </tr>
          <tr>
            <td><tt>h</tt></td>
            <td>Интрепретировать число как переменную типа <tt>short</tt> или <tt>unsigned short</tt> языка C.</td>
          </tr>
          <tr>
            <td><tt>h</tt></td>
            <td>Интрепретировать число как переменную типа <tt>short</tt> или <tt>unsigned short</tt> языка C.</td>
          </tr>
          <tr>
            <td><tt>V</tt></td>
            <td>Интрепретировать число как переменную стандартного целого типа языка PERL.</td>
          </tr>
          <tr>
            <td><tt>v</tt></td>
            <td>Интрепретировать строку как вектор кодов символов, при выводе разделять точками.</td>
          </tr>
          <tr>
            <td><tt>*v</tt></td>
            <td>Интрепретировать строку как вектор кодов символов, при выводе разделять следующим аргументом из списка.</td>
          </tr>
        </table>
      </div>

      <p>Вместо <em>числа</em> в качестве флага может быть задан символ *. В этом случае значение этого числа
      извлекается из очередного элемента списка аргументов. Если полученная таким образом ширина поля отрицательна,
      то поле выравнивается по левому краю.</p>
      
      <p>Примеры форматирования строк:</p>
      
      <div class="code">
<pre class="code">%s = sprintf "%#0.8x\n", 256;           # %s = "0x00000100"
%s = sprintf "%+10E\n", 256;            # %s = "+2.560000E+002"
%s = sprintf "Версия PERL: %vd\n", $^V; # %s = "Версия PERL: 5.6.0"</pre>
      </div>

      <h4><a name="hwrite">Функция write</a></h4>

<pre class="syntax"><strong><a name="fwrite">Синтаксис</a></strong>: write <em>файл</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла</pre>

      <p>Эта функция выводит форматированную запись в указанный <em>файл</em>, используя шаблон,
        ассоциированный с данным файлом. По умолчанию этот шаблон имеет то же имя, что и описатель файла,
        но шаблон, ассоциированный с файлом, принятым для вывода по умолчанию, может иметь любое имя; для
        связи его с файлом достаточно занести имя шаблона в переменную <tt>$~</tt>. Пример вызова этой
        функции см. в описании функции <tt><a href="#fformat">format</a></tt>.</p>

      <h3><a name="ref6113">6.11.3. Функции управления файлами</a></h3>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Функция</th>
            <th>Описание</th>
          </tr>
          <tr>
            <td><a href="#fattr"><tt>-<em>attr</em></tt></a></td>
            <td>Возвращает заданный атрибут файла.</td>
          </tr>
          <tr>
            <td><a href="#fchmod"><tt>chmod</tt></a></td>
            <td>Изменяет атрибуты файлов.</td>
          </tr>
          <tr>
            <td><a href="#fglob"><tt>glob</tt></a></td>
            <td>Возвращает список имен файлов, соответствующих образцу.</td>
          </tr>
          <tr>
            <td><a href="#flink"><tt>link</tt></a></td>
            <td>Связывает новый файл с существующим.</td>
          </tr>
          <tr>
            <td><a href="#flstat"><tt>lstat</tt></a></td>
            <td>Возвращает информацию о символической ссылке.</td>
          </tr>
          <tr>
            <td><a href="#frename"><tt>rename</tt></a></td>
            <td>Переименовывает файл.</td>
          </tr>
          <tr>
            <td><a href="#fstat"><tt>stat</tt></a></td>
            <td>Возвращает информацию о файле.</td>
          </tr>
          <tr>
            <td><a href="#funlink"><tt>unlink</tt></a></td>
            <td>Удаляет заданные файлы.</td>
          </tr>
          <tr>
            <td><a href="#futime"><tt>utime</tt></a></td>
            <td>Изменяет время последнего доступа и модификации файлов.</td>
          </tr>
        </table>
      </div>

      <h4><a name="hattr">Функция -attr</a></h4>

<pre class="syntax"><strong><a name="fattr">Синтаксис</a></strong>: -<em>attr</em> <em>файл</em>
<strong>Аргументы</strong>: <em>attr</em>&nbsp;&#151; буква, задающая атрибут файла
           <em>файл</em>&nbsp;&#151; описатель файла
<strong>Результат</strong>: логическое значение</pre>

      <p>Эта функция проверяет заданный атрибут <em>файла</em> и возвращает истину или ложь в зависимости от
        результатов проверки. Возможные атрибуты задаются следующими буквами:</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Атрибут</th>
            <th>Значение</th>
          </tr>
          <tr>
            <td><tt>-r</tt></td>
            <td>Файл доступен для чтения пользователю с данным эффективным UID.</td>
          </tr>
          <tr>
            <td><tt>-w</tt></td>
            <td>Файл доступен для записи пользователю с данным эффективным UID.</td>
          </tr>
          <tr>
            <td><tt>-x</tt></td>
            <td>Файл доступен для исполнения пользователю с данным эффективным UID.</td>
          </tr>
          <tr>
            <td><tt>-o</tt></td>
            <td>Файл принадлежит пользователю с данным эффективным UID.</td>
          </tr>
          <tr>
            <td><tt>-R</tt></td>
            <td>Файл доступен для чтения пользователю с данным реальным UID.</td>
          </tr>
          <tr>
            <td><tt>-W</tt></td>
            <td>Файл доступен для записи пользователю с данным реальным UID.</td>
          </tr>
          <tr>
            <td><tt>-X</tt></td>
            <td>Файл доступен для исполнения пользователю с данным реальным UID.</td>
          </tr>
          <tr>
            <td><tt>-O</tt></td>
            <td>Файл принадлежит пользователю с данным реальным UID.</td>
          </tr>
          <tr>
            <td><tt>-e</tt></td>
            <td>Файл существует.</td>
          </tr>
          <tr>
            <td><tt>-z</tt></td>
            <td>Файл имеет нулевой размер.</td>
          </tr>
          <tr>
            <td><tt>-s</tt></td>
            <td>Файл имеет ненулевой размер (возвращается размер файла).</td>
          </tr>
          <tr>
            <td><tt>-f</tt></td>
            <td>Это обычный файл.</td>
          </tr>
          <tr>
            <td><tt>-d</tt></td>
            <td>Это каталог.</td>
          </tr>
          <tr>
            <td><tt>-l</tt></td>
            <td>Это символическая ссылка.</td>
          </tr>
          <tr>
            <td><tt>-p</tt></td>
            <td>Это канал ввода-вывода (pipe).</td>
          </tr>
          <tr>
            <td><tt>-S</tt></td>
            <td>Это сокет.</td>
          </tr>
          <tr>
            <td><tt>-b</tt></td>
            <td>Это специальный блочный файл.</td>
          </tr>
          <tr>
            <td><tt>-c</tt></td>
            <td>Это специальный посимвольный файл.</td>
          </tr>
          <tr>
            <td><tt>-t</tt></td>
            <td>Это терминал (tty).</td>
          </tr>
          <tr>
            <td><tt>-u</tt></td>
            <td>У файла установлен бит setuid.</td>
          </tr>
          <tr>
            <td><tt>-g</tt></td>
            <td>У файла установлен бит setgid.</td>
          </tr>
          <tr>
            <td><tt>-k</tt></td>
            <td>У файла установлен бит sticky.</td>
          </tr>
          <tr>
            <td><tt>-T</tt></td>
            <td>Это текстовый файл.</td>
          </tr>
          <tr>
            <td><tt>-B</tt></td>
            <td>Это двоичный файл.</td>
          </tr>
          <tr>
            <td><tt>-M</tt></td>
            <td>Возраст файла в днях на момент запуска сценария.</td>
          </tr>
          <tr>
            <td><tt>-A</tt></td>
            <td>Возраст последнего доступа к файлу в днях на момент запуска сценария.</td>
          </tr>
          <tr>
            <td><tt>-C</tt></td>
            <td>Возраст последнего обновления файла в днях на момент запуска сценария.</td>
          </tr>
        </table>
      </div>
      <p>Пример:</p>

      <div class="code">
<pre class="code">print "Файл доступен для чтения\n" if -r FILE;</pre>
      </div>

      <h4><a name="hchmod">Функция chmod</a></h4>

<pre class="syntax"><strong><a name="fchmod">Синтаксис</a></strong>: chmod <em>маска</em>, <em>список</em>
<strong>Аргументы</strong>: <em>маска</em>&nbsp;&#151; числовое выражение
           <em>список</em>&nbsp;&#151; список имен файлов
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>chmod</strong> изменяет маску прав доступа к файлам, указанным в <em>списке</em>,
        на заданную, и возвращает количество файлов, у которых это изменение прошло успешно. <em>Маска</em>
        задается числом или символической константой из модуля Fcntl (нужна директива <code>use Fcntl ':mode'</code>).
        По традиции Unix элементы маски задаются восьмеричными числами, поэтому в следующей таблице значения
        символических констант приведены в восьмеричном виде:</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Символическое имя</th>
            <th>Число</th>
            <th>Операция</th>
          </tr>
          <tr>
            <td><tt>_S_IXOTH</tt></td>
            <td>00001</td>
            <td>Разрешается выполнение (для файлов) и поиск (для каталогов) прочим пользователям.</td>
          </tr>
          <tr>
            <td><tt>_S_IWOTH</tt></td>
            <td>00002</td>
            <td>Разрешается запись прочим пользователям.</td>
          </tr>
          <tr>
            <td><tt>_S_IROTH</tt></td>
            <td>00004</td>
            <td>Разрешается чтение прочим пользователям.</td>
          </tr>
          <tr>
            <td><tt>_S_IXGRP</tt></td>
            <td>00010</td>
            <td>Разрешается выполнение (для файлов) и поиск (для каталогов) членам группы.</td>
          </tr>
          <tr>
            <td><tt>_S_IWGRP</tt></td>
            <td>00020</td>
            <td>Разрешается запись членам группы.</td>
          </tr>
          <tr>
            <td><tt>_S_IRGRP</tt></td>
            <td>00040</td>
            <td>Разрешается чтение членам группы.</td>
          </tr>
          <tr>
            <td><tt>_S_IEXEC</tt></td>
            <td>00100</td>
            <td>Разрешается выполнение (для файлов) и поиск (для каталогов) владельцу.</td>
          </tr>
          <tr>
            <td><tt>_S_IWRITE</tt></td>
            <td>00200</td>
            <td>Разрешается запись владельцу.</td>
          </tr>
          <tr>
            <td><tt>_S_IREAD</tt></td>
            <td>00400</td>
            <td>Разрешается чтение владельцу.</td>
          </tr>
          <tr>
            <td><tt>_S_ISVTX</tt></td>
            <td>01000</td>
            <td>Бит принадлежности.</td>
          </tr>
          <tr>
            <td><tt>_S_ISGID</tt></td>
            <td>02000</td>
            <td>Установить группе права на выполнение.</td>
          </tr>
          <tr>
            <td><tt>_S_ISUID</tt></td>
            <td>04000</td>
            <td>Установить пользователю права на выполнение.</td>
          </tr>
        </table>
      </div>

      <p>В Windows поддерживаются только флаги <tt>_S_IEXEC</tt>, <tt>_S_IWRITE</tt> и <tt>_S_IREAD</tt>. Пример:</p>

      <div class="code">
<pre class="code">use Fcntl ':mode';
chmod _S_IREAD | _S_WRITE, 'myfile.txt';</pre>
      </div>

      <h4><a name="hglob">Функция glob</a></h4>

<pre class="syntax"><strong><a name="fglob">Синтаксис</a></strong>: glob <em>образец</em>?
<strong>Аргументы</strong>: <em>образец</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: список строк</pre>

      <p>Функция <strong>glob</strong> возвращает список имен файлов, соответствующих заданному <em>образцу</em>.
        Если <em>образец</em> опущен, то используется содержимое специальной переменной <tt>$_</tt>.
        Строка считается  образцом, если она содержит хотя бы один из специальных символов <tt>"?"</tt>, <tt>"*"</tt> или <tt>"["</tt>.
        Раскрытие образца&nbsp;&#151; это операция, преобразующая образец в список соответствующих ему полных имен файлов.
        Правила соответствия определены следующим образом:</p>
      <ul>
       <li><tt>"?"</tt> (не в квадратных  скобках) соответствует любому одиночному символу.</li>
       <li><tt>"*"</tt> (не в квадратных скобках) соответствует любой строке, включая пустую строку.</li>
      </ul>
      <p>Квадратные скобки используются для задания групп символов так же, как в <a href="perl04.htm#table69">регулярных выражениях PERL</a>.
        Можно задавать группы одиночных символов (<tt>"[abc]"</tt>), диапазоны символов (<tt>"[a-z0-9]"</tt>) и все символы, кроме указанных
        (<tt>"[!abc]"</tt>). Для включения в образец специального символа как обычного перед ним ставится обратная косая черта <tt>"\"</tt>. Примеры:</p>

      <div class="code">
<pre class="code">@list = glob '*.c';         # возвращает имена всех файлов, оканчивающихся на ".c"
@list = glob '*';           # возвращает имена всех файлов
                              (кроме тех, что начинаются с точки!)
@list = glob 'dir/%[0-9]*'; # возвращает имена всех файлов в каталоге dir, у которых
                              второй символ имени&nbsp;&#151; цифра</pre>
      </div>
      <p>В DOS и Windows использование этой функции с именами каталогов затруднительно, поскольку там имена
        каталогов разделяются не косой чертой <tt>"/"</tt>, а обратной косой чертой <tt>"\"</tt>, которая в <tt>glob</tt>
        имеет специальное назначение. Поэтому для этих систем существует специальный модуль File::DosGlob,
        который входит в стандартный дистрибутив PERL.</p>

      <h4><a name="hlink">Функция link</a></h4>

<pre class="syntax"><strong><a name="flink">Синтаксис</a></strong>: link <em>старое имя</em>, <em>новое имя</em>
<strong>Аргументы</strong>: <em>старое имя</em>, <em>новое имя</em>&nbsp;&#151; строковые выражения
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>link</strong> создает файл с <em>новым именем</em> и связывает его с существующим файлом, имеющим
        <em>старое имя</em>. Возвращает ненулевое значение при удачном завершении и нуль при неудаче.
        В Windows реализована только для файловой системы NTFS (Windows NT/2000).</p>

      <h4><a name="hlstat">Функция lstat</a></h4>

<pre class="syntax"><strong><a name="flstat">Синтаксис</a></strong>: lstat <em>файл</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла или имя файла
<strong>Результат</strong>: список значений</pre>

      <p>Функция <strong>lstat</strong> возвращает ту же информацию о файле, что и функция <tt><a href="#fstat">stat</a></tt>,
        но эта информация возвращается о символической ссылке, а не о файле, на который эта ссылка указывает.
        Если операционная система не поддерживает символические файловые ссылки, то эта функция эквивалентна <tt><a href="#fstat">stat</a></tt>.
        Если <em>файл</em> опущен, то используется содержимое специальной переменной <tt>$_</tt>.</p>

      <h4><a name="hrename">Функция rename</a></h4>

<pre class="syntax"><strong><a name="frename">Синтаксис</a></strong>: rename <em>старое имя</em>, <em>новое имя</em>
<strong>Аргументы</strong>: <em>старое имя</em>, <em>новое имя</em>&nbsp;&#151; строковые выражения
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>rename</strong> переименовывает файл со <em>старым именем</em>, присваивая ему
        <em>новое имя</em>. Возвращает ненулевое значение при удачном завершении и нуль при неудаче. Пример:</p>

      <div class="code">
<pre class="code">rename 'myfile.txt', 'mynewfile.txt';</pre>
      </div>

      <h4><a name="hstat">Функция stat</a></h4>

<pre class="syntax"><strong><a name="fstat">Синтаксис</a></strong>: stat <em>файл</em>?
<strong>Аргументы</strong>: <em>файл</em>&nbsp;&#151; описатель файла или имя файла
<strong>Результат</strong>: список значений</pre>

      <p>Функция <strong>stat</strong> возвращает массив информации о заданном <em>файле</em>. Если <em>файл</em> опущен,
        то используется содержимое специальной переменной <tt>$_</tt>. При неудаче возвращается нулевое значение.
        Информационный массив имеет следующее строение:</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Индекс</th>
            <th>Содержимое</th>
          </tr>
          <tr>
            <td>0</td>
            <td>Номер устройства в файловой системе.</td>
          </tr>
          <tr>
            <td>1</td>
            <td>Номер узла (inode).</td>
          </tr>
          <tr>
            <td>2</td>
            <td>Режим файла (тип и маска прав доступа).</td>
          </tr>
          <tr>
            <td>3</td>
            <td>Число жестких ссылок на файл.</td>
          </tr>
          <tr>
            <td>4</td>
            <td>UID владельца файла.</td>
          </tr>
          <tr>
            <td>5</td>
            <td>GID владельца файла.</td>
          </tr>
          <tr>
            <td>6</td>
            <td>Идентификатор устройства (для специальных файлов).</td>
          </tr>
          <tr>
            <td>7</td>
            <td>Размер файла в байтах.</td>
          </tr>
          <tr>
            <td>8</td>
            <td>Время последнего доступа к файлу.</td>
          </tr>
          <tr>
            <td>9</td>
            <td>Время последнего изменения файла.</td>
          </tr>
          <tr>
            <td>10</td>
            <td>Время изменения узла (inode).</td>
          </tr>
          <tr>
            <td>11</td>
            <td>Размер блока файловой системы.</td>
          </tr>
          <tr>
            <td>12</td>
            <td>Количество блоков, выделенных файлу.</td>
          </tr>
        </table>
      </div>
      <p>Все времена в этом массиве хранятся как количество секунд с начала эпохи, за которую принято
        00:00 по Гринвичу 1 января 1970 г. В Windows поля 0, 1 и 10 лишены смысла. Типичный пример:</p>

      <div class="code">
<pre class="code">($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime,
 $blksize, $blocks) = stat('myfile.txt');</pre>
      </div>

      <p>Если параметром <em>файл</em> является символ <tt>_</tt>, то возвращается массив данных от последнего вызова <tt>stat</tt>.
      В скалярном контексте возвращается логическое значение, означающее успех или неудачу, и в случае удачи
      заполняется внутренний массив, который может быть считан вызовом <code>stat(_)</code>.</p>

      <h4><a name="hunlink">Функция unlink</a></h4>

<pre class="syntax"><strong><a name="funlink">Синтаксис</a></strong>: unlink <em>список</em>?
<strong>Аргументы</strong>: <em>список</em>&nbsp;&#151; список строковых выражений
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>unlink</strong> удаляет файлы, имена которых перечислены в <em>списке</em>. Если <em>список</em> опущен,
        то используется содержимое специальной переменной <tt>$_</tt>. Возвращается количество успешно удаленных файлов.
        Примеры:</p>

      <div class="code">
<pre class="code">$count = unlink 'a.txt', 'b.txt', 'c.txt';
unlink @list;
unlink &lt;*.bak&gt;;</pre>
      </div>

      <p>Для удаления каталогов следует пользоваться функцией <tt><a href="#frmdir">rmdir</a></tt>.</p>

      <h4><a name="hutime">Функция utime</a></h4>

<pre class="syntax"><strong><a name="futime">Синтаксис</a></strong>: utime <em>список</em>?
<strong>Аргументы</strong>: <em>список</em>&nbsp;&#151; список строковых выражений
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>utime</strong> изменяет время последнего доступа и последнего изменения у файлов, имена которых перечислены в <em>списке</em>.
        Новые значения этих времен должны быть первыми двумя элементами <em>списка</em>. Если <em>список</em> опущен, то используется
        содержимое специальной переменной <tt>$_</tt>. Возвращается количество успешно измененных файлов. Пример:</p>

      <div class="code">
<pre class="code">$now = time;
utime $now, $now, 'myfile.txt';</pre>
      </div>
      
      <p>В Windows 95/98 с файловой системой FAT время последнего доступа к файлу не поддерживается, поэтому
        данная функция изменяет только время последнего изменения заданных файлов.</p>

      <h3><a name="ref6114">6.11.4. Функции управления каталогами</a></h3>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Функция</th>
            <th>Описание</th>
          </tr>
          <tr>
            <td><a href="#fchdir"><tt>chdir</tt></a></td>
            <td>Изменяет текущий каталог.</td>
          </tr>
          <tr>
            <td><a href="#fclosedir"><tt>closedir</tt></a></td>
            <td>Закрывает каталог.</td>
          </tr>
          <tr>
            <td><a href="#fmkdir"><tt>mkdir</tt></a></td>
            <td>Создает новый каталог.</td>
          </tr>
          <tr>
            <td><a href="#fopendir"><tt>opendir</tt></a></td>
            <td>Открывает заданный каталог.</td>
          </tr>
          <tr>
            <td><a href="#freaddir"><tt>readdir</tt></a></td>
            <td>Считывает очередной элемент каталога.</td>
          </tr>
          <tr>
            <td><a href="#frewinddir"><tt>rewinddir</tt></a></td>
            <td>Возвращается к началу каталога.</td>
          </tr>
          <tr>
            <td><a href="#frmdir"><tt>rmdir</tt></a></td>
            <td>Удаляет заданный каталог.</td>
          </tr>
          <tr>
            <td><a href="#fseekdir"><tt>seekdir</tt></a></td>
            <td>Изменяет текущую позицию в каталоге.</td>
          </tr>
          <tr>
            <td><a href="#ftelldir"><tt>telldir</tt></a></td>
            <td>Возвращает текущую позицию в каталоге.</td>
          </tr>
        </table>
      </div>

      <h4 class="vindent"><a name="hchdir">Функция chdir</a></h4>

<pre class="syntax"><strong><a name="fchdir">Синтаксис</a></strong>: chdir <em>имя</em>?
<strong>Аргументы</strong>: <em>имя</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>chdir</strong> изменяет текущий рабочий каталог на каталог с заданным <em>именем</em>. Если <em>имя</em> опущено,
        то используется каталог, заданный в переменной среды <tt>$ENV{HOME}</tt>; если такой переменной нет, то
        используется каталог, заданный в переменной среды <tt>$ENV{LOGDIR}</tt>; если и ее нет, то не делается ничего.
        Возвращается истина при успешной смене текущего каталога и ложь при неудаче. Пример:</p>

      <div class="code">
<pre class="code">chdir "c:\\windows\\temp" or die "Не могу сменить каталог: $!\n";</pre>
      </div>
      
      <h4><a name="hclosedir">Функция closedir</a></h4>

<pre class="syntax"><strong><a name="fclosedir">Синтаксис</a></strong>: closedir <em>каталог</em>
<strong>Аргументы</strong>: <em>каталог</em>&nbsp;&#151; описатель каталога
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>closedir</strong> закрывает <em>каталог</em>, ранее открытый функцией <tt><a href="#fopendir">opendir</a></tt>.
        Возвращается истина при успешном закрытии каталога и ложь при неудаче. Пример см. в описании <tt><a href="#fopendir">opendir</a></tt>.</p>

      <h4><a name="hmkdir">Функция mkdir</a></h4>

<pre class="syntax"><strong><a name="fmkdir">Синтаксис</a></strong>: mkdir <em>имя</em>, <em>маска</em>?
<strong>Аргументы</strong>: <em>имя</em>&nbsp;&#151; строковое выражение
           <em>маска</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>mkdir</strong> создает новый каталог с заданным <em>именем</em> и заданной <em>маской</em>
        прав доступа. Права доступа задаются так же, как в функции <tt><a href="perl12.htm#fumask">umask</a></tt>; если <em>маска</em> опущена,
        то ее значение принимается равным 0777. Возвращается истина при успешной смене текущего каталога и ложь при неудаче. Пример:</p>

      <div class="code">
<pre class="code">mkdir "c:\\mydir" or die "Не могу создать каталог: $!\n";</pre>
      </div>
      
      <h4><a name="hopendir">Функция opendir</a></h4>

<pre class="syntax"><strong><a name="fopendir">Синтаксис</a></strong>: opendir <em>каталог</em>, <em>имя</em>
<strong>Аргументы</strong>: <em>каталог</em>&nbsp;&#151; описатель каталога
           <em>имя</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>opendir</strong> открывает каталог с заданным <em>именем</em> и заносит его описатель в
        переменную <em>каталог</em>. Возвращается истина при успешном открытии каталога и ложь при неудаче. Описатели
        открытых каталогов используются функциями <a href="#freaddir"><tt>readdir</tt></a>, <a href="#ftelldir"><tt>telldir</tt></a>,
        <a href="#fseekdir"><tt>seekdir</tt></a>, <a href="#frewinddir"><tt>rewinddir</tt></a> и <a href="#fclosedir"><tt>closedir</tt></a>.
        Следует помнить, что описатели каталогов имеют собственное пространство имен, не совпадающее с пространством имен описателей файлов.</p>
      <p>Приведем пример, который выводит на экран имена всех файлов в текущем каталоге Windows с расширением '.pl':</p>

      <div class="code">
<pre class="code">opendir(DIR, '.');
@files = grep {!(/^\./) && /\.pl$/} readdir(DIR);
closedir(DIR);
print "$_\n" foreach @files;</pre>
      </div>
      
      <h4><a name="hreaddir">Функция readdir</a></h4>

<pre class="syntax"><strong><a name="freaddir">Синтаксис</a></strong>: readdir <em>каталог</em>
<strong>Аргументы</strong>: <em>каталог</em>&nbsp;&#151; описатель каталога
<strong>Результат</strong>: строка или список строк</pre>

      <p>Функция <strong>readdir</strong> считывает очередной элемент <em>каталога</em>, открытого функцией <tt><a href="#fopendir">opendir</a></tt>
        и возвращает его. В списочном контексте возвращается список всех элементов <em>каталога</em> с текущего элемента и до конца.
        Если каталог просмотрен до конца, то возвращается <strong>undef</strong> в скалярном контексте и нулевой список в списочном контексте.
        Пример см. в описании <tt><a href="#fopendir">opendir</a></tt>.</p>

      <h4><a name="hrewinddir">Функция rewinddir</a></h4>

<pre class="syntax"><strong><a name="frewinddir">Синтаксис</a></strong>: rewinddir <em>каталог</em>
<strong>Аргументы</strong>: <em>каталог</em>&nbsp;&#151; описатель каталога</pre>

      <p>Функция <strong>rewinddir</strong> "перематывает" заданный <em>каталог</em> в начало. Она используется совместно
        с функцией <tt><a href="#freaddir">readdir</a></tt> для многократного просмотра элементов каталога.</p>

      <h4><a name="hrmdir">Функция rmdir</a></h4>

<pre class="syntax"><strong><a name="frmdir">Синтаксис</a></strong>: rmdir <em>имя</em>?
<strong>Аргументы</strong>: <em>имя</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>rmdir</strong> удаляет каталог с заданный <em>именем</em>. Если аргумент опущен, то используется
        содержимое специальной переменной <tt>$_</tt>. Удаление каталога возможно только тогда, когда в нем нет файлов.
        Возвращается истина при успешном удалении каталога и ложь при неудаче. Пример:</p>

      <div class="code">
<pre class="code">rmdir "c:\\mydir" or die "Не могу удалить каталог: $!\n";</pre>
      </div>
      
      <h4><a name="hseekdir">Функция seekdir</a></h4>

<pre class="syntax"><strong><a name="fseekdir">Синтаксис</a></strong>: seekdir <em>каталог</em>, <em>позиция</em>
<strong>Аргументы</strong>: <em>каталог</em>&nbsp;&#151; описатель каталога
           <em>позиция</em>&nbsp;&#151; числовое выражение</pre>

      <p>Функция <strong>seekdir</strong> устанавливает текущую позицию в заданном <em>каталоге</em> равной заданной <em>позиции</em>.
        <em>Позиция</em> должна быть значением, ранее полученным вызовом функции <a href="#ftelldir"><tt>telldir</tt></a>.</p>

      <h4><a name="htelldir">Функция telldir</a></h4>

<pre class="syntax"><strong><a name="ftelldir">Синтаксис</a></strong>: telldir <em>каталог</em>
<strong>Аргументы</strong>: <em>каталог</em>&nbsp;&#151; описатель каталога
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>telldir</strong> возвращает текущую позицию в заданном <em>каталоге</em>. Это значение
        может быть в дальнейшем использовано для вызова функции <a href="#fseekdir"><tt>seekdir</tt></a>.</p>

    </td></tr>
  <tr><td><div id="divFooter"></div></td></tr>
</table>
</body>
</html>
