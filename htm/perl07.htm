<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Author" content="Юрий Лукач">
<meta name="Description" content="Справочник Веб-разработчика: современные технологии WWW">
<meta name="Keywords" content="WWW, Веб, разработка, программирование, HTML, DHTML, CSS, Java, JavaScript, CGI, PERL, ASP, XML, XSL, VML, VRML">
<title>WDH: PERL - Пакеты и модули</title>
<link rel="Prev" href="perl06.htm" title="Подпрограммы">
<link rel="Next" href="perl08.htm" title="Классы и объекты">
<link rel="Copyright" href="cpyright.htm" title="Сведения об авторских правах">
<link rev="Made" href="mailto:yury@suncloud.ru" title="Обратная связь">
<script type="text/javascript" src="global/load.js"></script>
<script type="text/javascript" src="global/link.js"></script>
</head>

<body onLoad="initDoc(); addBanner(true)">
<table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin: 0">
  <tr><td><div id="divHeader"></div></td></tr>
  <tr><td id="tdBanner" style="text-align: center"><script type="text/javascript">addBanner(false);</script></td></tr>
  <tr><td>

      <h2><a name="ref67">Глава 6.7. Пакеты и модули</a></h2>

      <h3><a name="ref671">6.7.1. Пакеты</a></h3>

      <h4><a name="ref6711">6.7.1.1. Понятие пакета</a></h4>

      <p>PERL поддерживает разбиение программ на пакеты, каждый из которых имеет собственное пространство имен.
        <em>Пакет</em> (package)&nbsp;&#151; это просто отдельный файл, содержащий подпрограммы, константы и переменные.
        Такой файл компилируется независимо от остальных пакетов и имеет собственное пространство имен. Обычно пакет имеет
        расширение .pl или .pm (Perl Module). Пакет должен содержать оператор</p>

<pre class="syntax">package <em>имя</em></pre>

      <p class="noindent">который задает название его пространства имен. Этот оператор действует до конца блока, <tt>eval</tt> или текущего файла.</p>

      <p>Для включения пакета в программу мы используем встроенные функции <tt>require()</tt> или <tt>use()</tt>.
        Такой оператор называется <em>декларацией пакета</em> и действует до конца блока, <tt>eval</tt> или текущего файла.
        Чаще всего декларации пакетов размещаются в начале PERL-программ и действуют во всем файле.</p>

      <p>Рассмотрим в качестве примера пакет Cwd, который входит в стандартный дистрибутив PERLа. Этот пакет содержит несколько функций,
        позволяющих нам считывать и изменять текущий каталог операционной системы. В частности, он содержит функцию <tt>cwd()</tt>,
        возвращающую текущий каталог, и функцию <tt>chdir()</tt>, изменяющую текущий каталог. Для того, чтобы пользоваться всеми функциями
        пакета Cwd, мы должны включить в свою программу директиву <code>use Cwd</code>, например:</p>

      <div class="code">
<pre class="code">use Cwd;
$curdir = cwd;
print "$curdir\n";</pre>
      </div>

      <p>Эта программа выводит на экран имя текущего каталога. Директива <code>use Cwd</code> добавляет имена из пакета Cwd
        к пространству имен нашей программы, поэтому мы можем обращаться к функции <tt>cwd()</tt> так, как если бы она была описана в нашей
        программе. При желании мы можем импортировать из пакета только отдельные его функции, например:</p>

      <div class="code">
<pre class="code">use Cwd 'chdir';     # импорт chdir из пакета Cwd
chdir "/temp";       # вызов функции chdir пакета Cwd
Cwd::chdir "/temp";  # то же самое
CORE::chdir "/temp"; # вызов встроенной функции chdir</pre>
      </div>

      <p>Этот пример демонстрирует применение квалификатора <tt><em>пакет</em>::<em>имя</em></tt>. По сути дела, такая конструкция указывает компилятору,
        какое пространство имен нужно использовать. PERL поддерживает два специальных имени пакетов:</p>
      <ul>
        <li><tt>main</tt>&nbsp;&#151; пространство имен главной программы. Принято по умолчанию, т.&nbsp;е. <tt>$::var</tt> эквивалентно <tt>$main::var</tt>.</li>
        <li><tt>CORE</tt>&nbsp;&#151; пространство имен встроенных функций. Подробнее о нем см. <a href="perl06.htm#ref669">п. 6.6.9</a>.</li>
      </ul>

      <p>PERL допускает использование составных имен пакетов вида <tt><em>имя1</em>::<em>имя2</em></tt>. Такая конструкция
        предназначена для удобства классификации; кроме того, она указывает компилятору, где искать данный пакет. Сложные имена
        пакетов соответствуют дереву подкаталогов в библиотечном каталоге PERLа. Например, дистрибутив содержит пакеты File::Compare,
        File::Copy, File::Find и т.&nbsp;п. Эти имена говорят компилятору, что соответствующие пакеты хранятся в файлах File/Compare.pm,
        File/Copy.pm и File/Find.pm библиотечного каталога соответственно (в системе Unix; в Windows, MacOS или VMS разделитель имени
        каталога и файла будет другим, но сути это не меняет). Главное, что при этом нужно понимать: составное имя пакета ничего не означает
        помимо сказанного. PERL не поддерживает относительных или вложенных пакетов, наследования и т.&nbsp;п. Каждый пакет, как бы мы его
        не назвали, является самостоятельной единицей компиляции, не связанной с другими пакетами. В частности, пакеты с именами OUTER::INNER и INNER
        не имеют ничего общего.</p>

      <p>Таблица символов пакета содержит только обычные его идентификаторы. Все специальные переменные и массивы всегда относятся к пространству имен
        <tt>main</tt> и не могут быть переопределены в пакетах.</p>

      <h4><a name="ref6712">6.7.1.2. Таблицы символов</a></h4>

      <p>Таблица символов (т.&nbsp;е. список имен) пакета хранится в ассоциативном массиве с именем <tt>%<em>имя</em>::</tt>. Так, таблица символов главной программы
        содержится в ассоциативном массиве <tt>%main::</tt> или, короче, <tt>%::</tt>, а таблица символов пакета File::Copy&nbsp;&#151;
        в ассоциативном массиве <tt>%File::Copy::</tt>.</p>
      <p>Элемент этого ассоциативного массива <tt>$package::{name}</tt>&nbsp;&#151; то же самое, что результат операции <tt><a href="perl02.htm#ref6210">*name</a></tt>.
        Например, следующие операторы эквивалентны (но первый эффективнее, потому что проводит поиск по таблице на этапе компиляции):</p>

      <div class="code">
<pre class="code">local *main::x   = *main::y;
local $main::{x} = $main::{y};</pre>
      </div>

      <p>Мы можем, например, распечатать все переменные главной программы следующим оператором:</p>

      <div class="code">
<pre class="code">print "$main::{$_}\n" foreach keys %main::;</pre>
      </div>

      <p>С элементами таблицы символов связаны еще несколько специальных конструкций, позволяющих получить о них дополнительную информацию.
        Все эти конструкции имеют вид <tt>*name{THING}</tt>, где <tt>THING</tt>&nbsp;&#151; ключевое слово, указывающее вид возвращаемой информации:</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Конструкция</th>
            <th>Значение</th>
          </tr>
          <tr>
            <td><tt>*name{PACKAGE}</tt></td>
            <td>Имя пакета, в котором определено <tt>name</tt>.</td>
          </tr>
          <tr>
            <td><tt>*name{NAME}</tt></td>
            <td>Имя элемента (т.&nbsp;е. <tt>name</tt>).</td>
          </tr>
          <tr>
            <td><tt>*name{SCALAR}</tt></td>
            <td>Ссылка на скалярную переменную <tt>$name</tt>.</td>
          </tr>
          <tr>
            <td><tt>*name{ARRAY}</tt></td>
            <td>Ссылка на массив <tt>@name</tt>.</td>
          </tr>
          <tr>
            <td><tt>*name{HASH}</tt></td>
            <td>Ссылка на ассоциативный массив <tt>%name</tt>.</td>
          </tr>
          <tr>
            <td><tt>*name{CODE}</tt></td>
            <td>Ссылка на подпрограмму <tt>&amp;name</tt>.</td>
          </tr>
          <tr>
            <td><tt>*name{IO}</tt>, <tt>*name{FILEHANDLE}</tt></td>
            <td>Ссылка на указатель файла с именем <tt>name</tt>.</td>
          </tr>
          <tr>
            <td><tt>*name{GLOB}</tt></td>
            <td>Ссылка на typeglob для <tt>name</tt>.</td>
          </tr>
        </table>
      </div>

      <p>Пример:</p>

      <div class="code">
<pre class="code">sub identify {
  my $glob = shift;
  print *{$glob}{PACKAGE}, '::', *{$glob}{NAME}, "\n";
}

use Cwd;
identify *STDIN;    # выводит "main::STDIN"
identify *Cwd::cwd; # выводит "Cwd::cwd"</pre>
      </div>

      <h4><a name="ref6713">6.7.1.3. Конструкторы и деструкторы пакетов</a></h4>

      <p>Пакет может содержать четыре специальных подпрограммы: <tt>BEGIN</tt>, <tt>CHECK</tt>, <tt>INIT</tt> и <tt>END</tt>.
        Перед именами этих подпрограмм ключевое слово <tt>sub</tt> необязательно.</p>

      <p>Подпрограмма <tt>BEGIN</tt> играет роль конструктора пакета. Она начинает выполняться, как только будет полностью загружена и скомпилирована,
        даже если остаток файла еще компилируется. Мы можем разместить в пакете несколько блоков <tt>BEGIN</tt>; они будут выполняться
        в порядке их размещения в файле. После исполнения этой подпрограммы она немедленно становится неопределенной и больше не может
        быть вызвана.</p>

      <p>Подпрограммы <tt>INIT</tt> аналогичны <tt>BEGIN</tt>, но исполняются перед запуском исполняющей системы PERLа. Они могут использоваться для
        инициализации пакетов.</p>

      <p>Подпрограмма <tt>END</tt> играет роль деструктора пакета. Она выполняется сразу после завершения программы (безразлично, нормального
        или по фатальной ошибке), но перед завершением работы интерпретатора. Мы можем разместить в пакете несколько блоков <tt>END</tt>; они
        будут выполняться в порядке, обратном их размещению в файле. Блоки <tt>END</tt> не выполняются, если perl запущен с опцией <tt>-c</tt>.
        Внутри подпрограммы <tt>END</tt> специальная переменная <tt>$?</tt> содержит код завершения программы, значение которой здесь можно изменить.</p>

      <p>Подпрограммы <tt>CHECK</tt> аналогичны <tt>END</tt>, но исполняются после завершения компиляции, но до начала исполнения программы. Они могут использоваться для
        проверки и сохранения компилированного кода программы.</p>

      <h4><a name="ref6714">6.7.1.4. Функции require, use и no</a></h4>

      <p>Выше мы упомянули, что для включения пакета в программу используются встроенные функции <tt>require</tt> и <tt>use</tt>. Рассмотрим эти
        функции подробнее. Функция <tt>require</tt> имеет вид:</p>

<pre class="syntax">require <em>выражение</em></pre>

      <p>Если <em>выражение</em> опущено, то берется значение переменной <tt>$_</tt>. Действия этой функции определяются семантикой <em>выражения</em>.
        Есди оно является числом или константой вида 'v5.6.1', то <tt>require</tt> проверяет, что текущая версия PERLа (<tt>$^V</tt>) не ниже заданной <em>выражением</em>.
        Если это не так, то работа программы завершается с соответствующей диагностикой. Примеры:</p>

      <div class="code">
<pre class="code">require v5.6.0; # проверка версии PERL 5.6.0
require 5.6.0;  # то же самое
require 5.6;    # эквивалентно require v5.600.0
require 5;      # проверка версии PERL 5</pre>
      </div>

      <p>В остальных случаях <em>выражение</em> задает имя пакета, который нужно включить в наш файл. В этом случае <tt>require</tt> выполняет следующие действия:</p>
      <ul>
        <li>Если выражение является словом, то к нему добавляется расширение .pm, а все <tt>::</tt> в нем заменяются на символ <tt>/</tt>.</li>
        <li>Если полученное имя файла уже содержится в ассоциативном массиве <tt>%INC</tt>, то функция возвращает 1.</li>
        <li>В противном случае функция просматривает каталоги, заданные в массиве @INC, в поисках заданного файла. Если такого файла нет,
          то программа завершается с соответствующей диагностикой.</li>
        <li>Если файл найден, то выполняется операция <tt>do <em>имя_файла</em></tt>. Если она возвращает ложь, то программа завершается
          с соответствующей диагностикой, иначе функция возвращает результат операции <tt>do</tt>.</li>
      </ul>

      <p>Иными словами, функция <tt>require</tt> находит заданный файл пакета и выполняет его. Пакет обязан вернуть истину, указывая, что его инициализация прошла успешно,
        поэтому принято заканчивать любой пакет строкой <code>1;</code>, чтобы не забыть об этом требовании. Обратите внимание, что пакет загружается только один раз. Пример: оператор</p>

      <div class="code">
<pre class="code">require Some::Module</pre>
      </div>

      <p class="noindent">будет искать в каталогах массива <tt>@INC</tt> файл Some/Module.pm, поскольку аргументом функции является слово. Но операторы</p>

      <div class="code">
<pre class="code">$modname = 'Some::Module';
require $modname;</pre>
      </div>

      <p class="noindent">или</p>

      <div class="code">
<pre class="code">require "Some::Module";</pre>
      </div>

      <p class="noindent">будут искать (и, разумеется, не найдут) в каталогах массива <tt>@INC</tt> файл Some::Module, поскольку здесь аргументы функции не являются словами.
        В такой ситуации следует использовать конструкцию</p>

      <div class="code">
<pre class="code">eval "require $modname";</pre>
      </div>

      <p>Функция <tt>require</tt> выполняется на этапе исполнения программы. В большинстве случаях предпочтительнее производить поиск и загрузку пакетов
        на этапе компиляции, что обеспечивается функцией <tt>use</tt>, которая имеет следующие формы:</p>

<pre class="syntax"><a name="fuse"></a>use <em>выражение</em>
use <em>имя</em> <em>выражение</em> <em>список</em></pre>

      <p>Первая форма проверяет текущую версию PERLа так же, как и функция <tt>require</tt>, но на этапе компиляции программы.</p>

      <p>Во второй форме <em>имя</em> задает имя пакета, <em>выражение</em>&nbsp;&#151; его версию, а <em>список</em>&nbsp;&#151;
        список имен, которые нужно из этого пакета импортировать. <em>Имя</em> должно быть словом, <em>выражение</em> и <em>список</em> не обязательны.
        Без <em>выражения</em> эта функция эквивалентна конструкции</p>

      <div class="code">
<pre class="code">BEGIN { require <em>имя</em>; import <em>имя</em> <em>список</em> }</pre>
      </div>

      <p>Функция <tt>BEGIN</tt> обеспечивает выполнение указанных операторов на этапе компиляции; <tt>require</tt> загружает заданный модуль,
        а <tt>import</tt> вызывает загрузку из модуля перечисленных в списке имен. Реализация метода <tt>import</tt> определяется модулем, который
        мы загружаем. Вызов функции <tt>use</tt> с пустым списком</p>

<pre class="syntax">use <em>имя</em> ()</pre>

      <p class="noindent">эквивалентен конструкции</p>

      <div class="code">
<pre class="code">BEGIN { require <em>имя</em> }</pre>
      </div>

      <p>Если <em>выражение</em> задано, то <tt>use</tt> вызывает метод <tt>VERSION</tt> класса <em>имя</em>, передавая ему <em>выражение</em> в качестве аргумента.
        Обычно метод <tt>VERSION</tt> сравнивает переданный ему аргумент с переменной <tt>$<em>имя</em>::VERSION</tt> и аварийно завершает работу программу, если
        затребованная версия больше, чем его.</p>

      <p><a name="fno"></a>Противоположностью функции <tt>use</tt> является функция <tt>no</tt>, имеющая вид</p>

<pre class="syntax">no <em>имя</em> <em>список</em></pre>

      <p>Эта функция вызывает метод <code>unimport <em>имя</em> <em>список</em></code> или завершается по фатальной ошибке, если модуль не имеет этого метода.</p>

      <p>В общем случае использование функции <tt>use</tt> предпочтительнее функции <tt>require</tt>, т.&nbsp;к. она проверяет наличие запрошенного модуля
        и импортируемых символов в нем при компиляции программы, а не посреди ее выполнения. Существует, однако, ситуация, в которой функция <tt>use</tt> не применима,
        а именно тот случай, когда два модуля обращаются к подпрограммам или переменным друг друга. В этой ситуации мы должны использовать функцию <tt>require</tt>.</p>

      <h4><a name="ref6715">6.7.1.5. Глобальные переменные: функция our</a></h4>

      <p>Функция <tt>our()</tt> аналогична функции <tt><a href="perl06.htm#ref663">my()</a></tt>, но создает не локальные, а глобальные переменные.
        Единственное ее применение состоит в том, что директива <tt>use strict vars</tt> позволяет обращаться
        к переменным, декларированным функцией <tt>our()</tt>, без указания имени пакета в пределах области действия этой функции.
        Синтаксис функции <tt>our()</tt> такой же, как у <tt><a href="perl06.htm#ref663">my()</a></tt>:</p>

      <div class="code">
<pre class="code">our $var;
our ($var1, $var2);</pre>
      </div>

      <h3><a name="ref672">6.7.2. Модули</a></h3>

      <h4><a name="ref6721">6.7.2.1. Понятие модуля</a></h4>

      <p><em>Модуль</em> (module)&nbsp;&#151; это пакет, предназначенный для использования другими модулями или программами. Модули&nbsp;&#151;
        новое понятие для PERLа, которое появилось в его версии 5. Существует несколько механизмов импорта подпрограмм и переменных модуля (вспомните
        лозунг PERLа!), но мы сосредоточим свое внимание на объектно-ориентированной реализации модулей, поскольку она предоставляет программисту
        наиболее гибкие возможности и соответствует современным технологическим требованиям. Правила написания модулей мы подробно рассматриваем в
        следующей главе. Здесь же мы приводится краткий обзор библиотеки PERLа и самого важного в ней для создания собственных модулей модуля Exporter.</p>

      <h4><a name="ref6722">6.7.2.2. Библиотечные модули</a></h4>

      <p>В состав дистрибутива PERLа входит обширная библиотека готовых модулей. В основном это файлы с расширением .pm, но некоторые могут иметь
        расширения .so (компилированные библиотечные файлы) или .al (автозагружаемые фрагменты модулей). Такие файлы создаются автоматически в процессе
        инсталяции модулей в систему. Старые библиотеки в формате PERL 4 могут иметь расширения .pl или .ph. Все библиотечные модули PERLа можно разбить на
        следующие категории:</p>
      <ul>
        <li><em>Директивные модули</em> (pragmatic modules). Это модули, которые играют роль директив, управляющих компилятором. Например, директива
          <code>use integer</code> просто загружает директивный модуль integer, а директива <code>no integer</code> отключает его использование.
          Полный список директивных модулей приведен в <a href="perllib.htm#table231a">Таблице П23.1</a>.</li>
        <li><em>Стандартные модули</em> (standard modules). Это модули, которые тщательно оттестированы и включены во все дистрибутивы PERLа, поэтому мы
          можем быть уверены, что их использование не вызовет проблем при переносе программ на другой компьютер (если, конечно, там установлена
          версия PERLа не ниже нашей). Полный список стандартных модулей приведен в <a href="perllib.htm#table232a">Таблице П23.2</a>.</li>
        <li>Прочие модули, набор которых варьируется для разных дистрибутивов. Если прагматические и стандартные модули размещаются в каталоге lib, то
          эти модули традиционно размещаются в каталоге site/lib. Помните, что они не обязаны присутствовать на всех компьютерах, где установлен PERL.
          Если нужного модуля на вашем компьютере не оказалось, то вы всегда можете загрузить его из CPAN.</li>
      </ul>

      <p>CPAN (Comprehensive Perl Archive Network) является общедоступным источником модулей PERL. Это архив материалов, связанных с языком PERL, содержащий
        документацию, учебники, утилиты и исходные тексты более чем тысячи модулей PERLа. Для использования модулей CPAN мы должны найти нужный нам модуль,
        загрузить его и инсталировать в системе. Базовыми узлами CPAN являются узлы <a target="_blank" href="http://cpan.perl.com/">http://cpan.perl.com/</a>
        и <a target="_blank" href="ftp://ftp.perl.org/pub/cpan/">ftp://ftp.perl.org/pub/CPAN/</a>; в России&nbsp;&#151; узлы
        <a target="_blank" href="ftp://ftp.chg.ru/pub/lang/perl/cpan/">ftp://ftp.chg.ru/pub/lang/perl/CPAN/</a>, <a target="_blank" href="ftp://cpan.rinet.ru/pub/mirror/cpan/">ftp://cpan.rinet.ru/pub/mirror/CPAN/</a>,
        <a target="_blank" href="ftp://ftp.aha.ru/pub/cpan/">ftp://ftp.aha.ru/pub/CPAN/</a> и <a target="_blank" href="ftp://ftp.sai.msu.su/pub/lang/perl/cpan/">ftp://ftp.sai.msu.su/pub/lang/perl/CPAN/</a>.</p>

      <h4><a name="ref6723">6.7.2.3. Модуль Exporter</a></h4>

      <p>Особое место среди стандартных модулей занимает модуль Exporter, поскольку он реализует стандартный метод <tt>import</tt>, которым пользуется большинство других модулей.
        Напомним, что метод <tt>import</tt> неявно вызывается функцией <tt>use()</tt> при загрузке модуля в программу.</p>

      <p>Допустим, что мы пишем текст модуля Sample. Тогда для использования модуля Exporter мы должны начать его со строк</p>

      <div class="code">
<pre class="code">package Sample;
require Exporter;              # загружаем модуль Exporter
@ISA = qw(Exporter);           # указываем, что неизвестные имена нужно искать в нем
                               # и определяем:
@EXPORT = qw(...);             # символы, экспортируемые по умолчанию
@EXPORT_OK = qw(...);          # символы, экспортируемые по запросу
%EXPORT_TAGS = (tag =&gt; [...]); # имена для наборов символов</pre>
      </div>

      <p>Массивы <tt>@EXPORT</tt> и <tt>@EXPORT_OK</tt> содержат списки символов, которые мы экспортируем во внешние пространства имен
        по умолчанию и по запросу соответственно. Экспортироваться могут переменные, подпрограммы или ссылки typeglob.
        Их имена обязаны содержать символ-префикс типа за исключением подпрограмм, для которых префикс <tt>&amp;</tt> необязателен. Пример:</p>

      <div class="code">
<pre class="code">@EXPORT_OK = qw(func %scalar @array %hash *typeglob); # func &#151; то же, что &amp;func</pre>
      </div>

      <p>Ассоциативный массив <tt>%EXPORT_TAGS</tt> дает нам еще один механизм выборочного импорта символов. Он позволяет связать с группами символов любые символьные теги.
        Задавая эти теги, мы можем импортировать соответствующие группы символов. Все символы, перечисленные в группах <tt>%EXPORT_TAGS</tt>, должны присутствовать в массивах <tt>@EXPORT</tt>
        и/или <tt>@EXPORT_OK</tt>. Например, программы, которые обращаются к модулю Sample, должны содержать один из операторов</p>

      <div class="code">
<pre class="code">use Sample;                        # импортировать символы, заданные по умолчанию
use Sample qw(...);                # импортировать символы, указанные в списке
use Sample @{$EXPORT_TAGS{'tag'}}; # импортировать группу символов с тегом tag
use Sample ();                     # не импортировать ничего</pre>
      </div>

      <p>Для удобства импорта введено следующее соглашение: если первое имя в списке импорта начинается с символа <tt>!</tt>, <tt>:</tt> или <tt>/</tt>, то этот список рассматривается как набор правил,
        управляющих списком импортируемых имен. Правила обрабатываются слева направо в соответствии со следующей таблицей:</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Конструкция</th>
            <th>Значение</th>
          </tr>
          <tr>
            <td><tt><em>name</em></tt></td>
            <td>Добавить имя <tt><em>name</em></tt>.</td>
          </tr>
          <tr>
            <td><tt>!<em>name</em></tt></td>
            <td>Удалить имя <tt><em>name</em></tt>.</td>
          </tr>
          <tr>
            <td><tt>:DEFAULT</tt></td>
            <td>Добавить все имена из списка <tt>@EXPORT</tt>.</td>
          </tr>
          <tr>
            <td><tt>!:DEFAULT</tt></td>
            <td>Удалить все имена из списка <tt>@EXPORT</tt>.</td>
          </tr>
          <tr>
            <td><tt>:<em>tag</em></tt></td>
            <td>Добавить все имена из списка <tt>%EXPORT_TAGS{<em>tag</em>}</tt>.</td>
          </tr>
          <tr>
            <td><tt>!:<em>tag</em></tt></td>
            <td>Удалить все имена из списка <tt>%EXPORT_TAGS{<em>tag</em>}</tt>.</td>
          </tr>
          <tr>
            <td><tt>/<em>pattern</em>/</tt></td>
            <td>Добавить все имена из списков <tt>@EXPORT</tt> и <tt>@EXPORT_OK</tt>, соответствующие образцу <tt><em>pattern</em></tt>.</td>
          </tr>
          <tr>
            <td><tt>!/<em>pattern</em>/</tt></td>
            <td>Удалить все имена из списков <tt>@EXPORT</tt> и <tt>@EXPORT_OK</tt>, соответствующие образцу <tt><em>pattern</em></tt>.</td>
          </tr>
        </table>
      </div>

      <p>Если список начинается с операции удаления, то считается, что ей предшествует операция :<tt>DEFAULT</tt>.</p>

      <p>Пусть наш модуль Sample содержит следующие операторы:</p>

      <div class="code">
<pre class="code">@EXPORT = qw(A1 A2 A3 A4 A5);
@EXPORT_OK = qw(B1 B2 B3 B4 B5);
%EXPORT_TAGS = (T1 =&gt; [qw(A1 A2 B1 B2)], T2 =&gt; [qw(A1 A2 B3 B4)]);</pre>
      </div>

      <p>Тогда программа, обращающаяся к Sample, могла бы содержать оператор</p>

      <div class="code">
<pre class="code">use Sample qw(:DEFAULT :T2 !B3 B5 /^.1/);
</pre>
      </div>

      <p class="noindent">который в данном случае эквивалентен оператору</p>

      <div class="code">
<pre class="code">use Sample qw(A1 A2 A3 A4 A5 B4 B5 B1);
</pre>
      </div>

      <p>Для отладки подобных конструкций удобно добавить в свою программу оператор <code>BEGIN { $Exporter::Verbose=1 }</code>,
        который выводит на консоль информацию об обработке операций импорта.</p>

      <p>Помимо описанных массивов модуль Exporter содержит несколько дополнительных возможностей, облегчающих управление экспортом символов.</p>

      <p>Поскольку все символы, перечисленные в <tt>%EXPORT_TAGS</tt>, обязаны присутствовать в <tt>@EXPORT</tt> или <tt>@EXPORT_OK</tt>, предусмотрены
        две функции <tt>export_tags</tt> и <tt>export_ok_tags</tt>, позволяющие легко добавлять символы в эти массивы. Пример:</p>

      <div class="code">
<pre class="code">%EXPORT_TAGS = (XXX =&gt; [qw(aa bb cc)], YYY =&gt; [qw(cc dd ee)]);
Exporter::export_tags('XXX');    # добавляет aa, bb и cc в @EXPORT
Exporter::export_ok_tags('YYY'); # добавляет cc, dd и ee в @EXPORT_OK</pre>
      </div>

      <p>Функция <tt>use()</tt> при проверке версии модуля вызывает метод <tt>$module_name-&gt;require_version($value)</tt>.
        В модуле Exporter этот метод реализован и проверяет переменную модуля <tt>$VERSION</tt>. При ее использовании нужно
        помнить, что версия рассматривается как плавающее число и потому 1.10 меньше, чем 1.9. Поэтому рекомендуется использовать
        номера версий с двумя цифрами после десятичной точки вида 1.09.</p>

      <p>Кроме того, Exporter содержит еще один метод, который используется в тех случаях, когда метод <tt>import</tt> модуля Exporter не
        может быть вызван напрямую. Этот метод имеет вид</p>

<pre class="syntax">MyPackage-&gt;export_to_level($level, $package, @what);</pre>

      <p class="noindent">где <tt>$level</tt>&nbsp;&#151; целое число, задающее уровень экспорта, т.&nbsp;е. количество модулей в стеке вызовов,
        на которое нужно подняться, а <tt>@what</tt>&nbsp;&#151; массив экспортируемых символов, обычно <tt>@_</tt>. Параметр <tt>$package</tt>
        зарезервирован для будущих версий. Пусть, например, наш модуль Sample содержит строки</p>

      <div class="code">
<pre class="code">@EXPORT_OK = qw($b);
sub import { $Sample::b = 1; Sample-&gt;export_to_level(1, @_); }</pre>
      </div>

      <p>Тогда оператор <code>use Sample ($b)</code> экспортирует переменную <tt>$Sample::b</tt> на один уровень вверх, т.&nbsp;е.
        в программу или модуль, вызвавшие модуль Sample.</p>

      <p>Наконец, Exporter позволяет нам явно запретить экспорт каких-либо символов. Имена таких символов должны быть указаны в
        массиве <tt>@EXPORT_FAIL</tt>. При попытке импортировать эти символы Exporter вызывает оператор</p>

      <div class="code">
<pre class="code">@failed_symbols = $module_name-&gt;export_fail(@failed_symbols);</pre>
      </div>

      <p>Если список, возвращаемый методом <tt>export_fail</tt>, пуст, то запрошенные символы экспортируются. В противном случае
        для каждого символа в этом списке генерируется соответствующее сообщение об ошибке. Мы можем переопределить в своем модуле метод
        <tt>export_fail</tt> или воспользоваться его реализацией по умолчанию, которая просто возвращает переданный ей список.</p>

    </td></tr>
  <tr><td><div id="divFooter"></div></td></tr>
</table>
</body>
</html>
