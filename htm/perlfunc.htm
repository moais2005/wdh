>\Q</tt>. Пример:</p>

      <div class="code">
<pre class="code">print quotemeta "abc123абв";  # "abc123\а\б\в"</pre>
      </div>

      <h4><a name="hsplit">Функция split</a></h4>

<pre class="syntax"><strong><a name="fsplit">Синтаксис</a></strong>: split <em>образец</em>, <em>строка</em>, <em>предел</em>
<strong>Аргументы</strong>: <em>образец</em>&nbsp;&#151; регулярное выражение
           <em>строка</em>&nbsp;&#151; строковое выражение
           <em>предел</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: список строк</pre>

      <p>Функция <strong>split</strong> расщепляет исходную <em>строку</em> на подстроки и возвращает список
        этих подстрок. В скалярном контексте она заносит список подстрок в массив <tt>@_</tt> и возвращает его длину.
        Если <em>строка</em> опущена, то она принимается равной значению переменной <tt>$_</tt>. Разбиение на подстроки
        происходит в позициях сопоставления с заданным <em>образцом</em>; если он опущен, то разбиение производится по
        символу пробела, при этом начальные пробелы в каждой подстроке удаляются. Если образец содержит круглые скобки, то
        подстроки, сопоставляемые с выражением в скобках, включаются в результирующий список как отдельные элементы.</p>
      <p>Если <em>предел</em> задан и положителен, то он задает максимально допустимое количество извлекаемых подстрок.
        Если он опущен или равен нулю, то конечные пустые подстроки не включаются в результирующий список. Если же он
        отрицательный, то возвращаются все извлеченные подстроки. Примеры:</p>

      <div class="code">
<pre class="code">@_ = split(/,/, 'a,b,c,d,');     # @_ = ('a', 'b', 'c', 'd')
@_ = split(/,/, 'a,b,c,d,', 3);  # @_ = ('a', 'b', 'c,d,')
@_ = split(/,/, 'a,b,c,d,', -3); # @_ = ('a', 'b', 'c', 'd', '')
@_ = split(/(,)/, 'a,b,c,d,');   # @_ = ('a', ',', 'b', ',', 'c', ',', 'd', ',')</pre>
      </div>

      <h4><a name="hstudy">Функция study</a></h4>

<pre class="syntax"><strong><a name="fstudy">Синтаксис</a></strong>: study <em>строка</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: нет</pre>

      <p>Функция <strong>study</strong> компилирует <em>строку</em> (или значение переменной <tt>$_</tt>, если она опущена)
        во внутреннее представление.  Если <em>строку</em> предполагается многократно сопоставлять с образцом, то ее
        компиляция может сэкономить время при последующих операциях сопоставления. В каждый момент времени только одна
        строка может быть скомпилирована; применение функции <strong>study</strong> к другой строке отменяет
        компиляцию текущей строки. Пример:</p>

      <div class="code">
<pre class="code">while (&lt;&gt;) {
  study;
  print "Мое\n" if /\bменя\b/;
  print "Твое\n" if /\bтебя\b/;
  ...
}</pre>
      </div>

    </td></tr>
  <tr><td><div id="divFooter"></div></td></tr>
</table>
</body>
</html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Author" content="Юрий Лукач">
<meta name="Description" content="Справочник Веб-разработчика: современные технологии WWW">
<meta name="Keywords" content="WWW, Веб, разработка, программирование, HTML, DHTML, CSS, Java, JavaScript, CGI, PERL, ASP, XML, XSL, VML, VRML">
<title>WDH: PERL - Встроенные функции (продолжение)</title>
<link rel="Prev" href="perl09.htm" title="Встроенные функции">
<link rel="Next" href="perl11.htm" title="Ввод-вывод, файлы и каталоги">
<link rel="Copyright" href="cpyright.htm" title="Сведения об авторских правах">
<link rev="Made" href="mailto:yury@suncloud.ru" title="Обратная связь">
<script type="text/javascript" src="global/load.js"></script>
<script type="text/javascript" src="global/link.js"></script>
</head>

<body onLoad="initDoc(); addBanner(true)">
<table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin: 0">
  <tr><td><div id="divHeader"></div></td></tr>
  <tr><td id="tdBanner" style="text-align: center"><script type="text/javascript">addBanner(false);</script></td></tr>
  <tr><td>

      <h2><a name="ref610">Глава 6.10. Встроенные функции (продолжение)</a></h2>

      <h3><a name="ref6101">6.10.1. Функции работы с массивами и списками</a></h3>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Функция</th>
            <th>Описание</th>
          </tr>
          <tr>
            <td><a href="#fgrep"><tt>grep</tt></a></td>
            <td>Проверяет заданное выражение для каждого элемента списка.</td>
          </tr>
          <tr>
            <td><a href="#fjoin"><tt>join</tt></a></td>
            <td>Объединяет элементы списка в одну строку.</td>
          </tr>
          <tr>
            <td><a href="#fmap"><tt>map</tt></a></td>
            <td>Вычисляет заданное выражение для каждого элемента списка.</td>
          </tr>
          <tr>
            <td><a href="#fpop"><tt>pop</tt></a></td>
            <td>Выталкивает последний элемент массива.</td>
          </tr>
          <tr>
            <td><a href="#fpush"><tt>push</tt></a></td>
            <td>Вталкивает элементы в конец массива.</td>
          </tr>
          <tr>
            <td><a href="#freverse"><tt>reverse</tt></a></td>
            <td>Переставляет элементы списка в обратном порядке.</td>
          </tr>
          <tr>
            <td><a href="#fshift"><tt>shift</tt></a></td>
            <td>Выталкивает первый элемент массива.</td>
          </tr>
          <tr>
            <td><a href="#fsort"><tt>sort</tt></a></td>
            <td>Сортирует список.</td>
          </tr>
          <tr>
            <td><a href="#fsplice"><tt>splice</tt></a></td>
            <td>Удаляет или заменяет часть элементов массива.</td>
          </tr>
          <tr>
            <td><a href="#funshift"><tt>unshift</tt></a></td>
            <td>Вталкивает элементы в начало массива.</td>
          </tr>
        </table>
      </div>

      <h4 class="vindent"><a name="hgrep">Функция grep</a></h4>

<pre class="syntax"><strong><a name="fgrep">Синтаксис</a></strong>: grep <em>аргумент</em>, <em>список</em>
<strong>Аргументы</strong>: <em>аргумент</em>&nbsp;&#151; выражение или блок
           <em>список</em>&nbsp;&#151; список выражений
<strong>Результат</strong>: список значений</pre>

      <p>Функция <strong>grep</strong> просматривает элементы <em>списка</em>, поочередно
        присваивая их переменной <tt>$_</tt>, для каждого элемента вычисляет значение <em>аргумента</em>
        и возвращает список тех элементов, для которых это значение истинно. В скалярном
        контексте возвращает количество элементов <em>списка</em>, для которых значение <em>аргумента</em>
        истинно. Помните, что возвращаемый список состоит из синонимов элементов исходного списка,
        поэтому изменение значений его элементов влечет изменение соответствующих элементов исходного списка.
        Следующий пример удаляет все комментарии из списка:</p>

      <div class="code">
<pre class="code">@x = ('aaa', '#comment1', 'bbb', '#comment2')
@y = grep {!/^#/} @x; # 'aaa', 'bbb'
@y = grep(!/^#/, @x); # то же самое</pre>
      </div>

      <h4><a name="hjoin">Функция join</a></h4>

<pre class="syntax"><strong><a name="fjoin">Синтаксис</a></strong>: join <em>разделитель</em>, <em>список</em>
<strong>Аргументы</strong>: <em>разделитель</em>&nbsp;&#151; строковое выражение
           <em>список</em>&nbsp;&#151; список выражений
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>join</strong> возвращает новую строку, состоящую из всех элементов <em>списка</em>,
        между которыми вставлено значение <em>разделителя</em>. Пример:</p>

      <div class="code">
<pre class="code">print join(': ', 'aaa', 'bbb', 'ccc');	# 'aaa: bbb: ccc'</pre>
      </div>

      <h4><a name="hmap">Функция map</a></h4>

<pre class="syntax"><strong><a name="fmap">Синтаксис</a></strong>: map <em>аргумент</em>, <em>список</em>
<strong>Аргументы</strong>: <em>аргумент</em>&nbsp;&#151; выражение или блок
           <em>список</em>&nbsp;&#151; список выражений
<strong>Результат</strong>: список значений</pre>

      <p>Функция <strong>map</strong> просматривает элементы <em>списка</em>, поочередно
        присваивая их переменной <tt>$_</tt>, для каждого элемента вычисляет значение <em>аргумента</em>
        и возвращает список полученных значений. В скалярном контексте возвращает размер списка,
        сгенерированного таким образом. Следующий пример преобразует числовые элементы массива в
        соответствующие символы:</p>

      <div class="code">
<pre class="code">@nums = (97, 98, 99);
@chars = map(chr, @nums); # ('a', 'b', 'c')</pre>
      </div>

      <h4><a name="hpop">Функция pop</a></h4>

<pre class="syntax"><strong><a name="fpop">Синтаксис</a></strong>: pop <em>массив</em>
<strong>Аргументы</strong>: <em>массив</em>&nbsp;&#151; именованный массив
<strong>Результат</strong>: скалярное значение</pre>

      <p>Функция <strong>pop</strong> удаляет из <em>массива</em> его последний элемент и возвращает его
        в качестве результата. Если аргумент опущен, то <em>массив</em> принимается равным переменной
        <tt>@ARGV</tt> в главной программе и <tt>@_</tt> в подпрограммах. Если <em>массив</em> пуст, то
        эта функция возвращает <strong>undef</strong>. Пример:</p>

      <div class="code">
<pre class="code">@a = (1, 2, 3, 4, 5);
print pop @a; # 5
print @a;     # (1, 2, 3, 4)</pre>
      </div>

      <h4><a name="hpush">Функция push</a></h4>

<pre class="syntax"><strong><a name="fpush">Синтаксис</a></strong>: push <em>массив</em>, <em>список</em>
<strong>Аргументы</strong>: <em>массив</em>&nbsp;&#151; именованный массив
           <em>список</em>&nbsp;&#151; список выражений
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>push</strong> добавляет элементы <em>списка</em> в конец <em>массива</em> и возвращает
        количество добавленных элементов. Пример:</p>

      <div class="code">
<pre class="code">@a = (1, 2, 3);
push @a, 4, 5;
print @a; # (1, 2, 3, 4, 5)</pre>
      </div>

      <h4><a name="hreverse">Функция reverse</a></h4>

<pre class="syntax"><strong><a name="freverse">Синтаксис</a></strong>: reverse <em>список</em>
<strong>Аргументы</strong>: <em>список</em>&nbsp;&#151; список выражений
<strong>Результат</strong>: список значений</pre>

      <p>Функция <strong>reverse</strong> возвращает список, состоящий из элементов исходного
        <em>списка</em>, расположенных в обратном порядке. В скалярном контексте она объединяет
        все элементы <em>списка</em> в строку и возвращает эту строку в обратном порядке символов.
        Примеры:</p>

      <div class="code">
<pre class="code">@a = (1, 2, 3);
@b = reverse @a; # (3, 2, 1)
$s = reverse @a; # '321'</pre>
      </div>

      <h4><a name="hshift">Функция shift</a></h4>

<pre class="syntax"><strong><a name="fshift">Синтаксис</a></strong>: shift <em>массив</em>
<strong>Аргументы</strong>: <em>массив</em>&nbsp;&#151; именованный массив
<strong>Результат</strong>: скалярное значение</pre>

      <p>Функция <strong>shift</strong> удаляет из <em>массива</em> его первый элемент и возвращает его
        в качестве результата. Если аргумент опущен, то <em>массив</em> принимается равным переменной
        <tt>@ARGV</tt> в главной программе и <tt>@_</tt> в подпрограммах. Если <em>массив</em> пуст, то
        эта функция возвращает <strong>undef</strong>. Пример:</p>

      <div class="code">
<pre class="code">@a = (1, 2, 3, 4, 5);
print shift @a; # 1
print @a;       # (2, 3, 4, 5)</pre>
      </div>

      <h4><a name="hsort">Функция sort</a></h4>

<pre class="syntax"><strong><a name="fsort">Синтаксис</a></strong>: sort <em>аргумент</em>, <em>список</em>
<strong>Аргументы</strong>: <em>аргумент</em>&nbsp;&#151; подпрограмма или блок
           <em>список</em>&nbsp;&#151; список выражений
<strong>Результат</strong>: список значений</pre>

      <p>Функция <strong>sort</strong> сортирует элементы <em>списка</em> и возвращает новый отсортированный список.
        Порядок сортировки задается <em>аргументом</em>. Если он опущен, то производится сортировка в лексикографическом
        порядке. В противном случае <em>аргумент</em> должен быть либо именем подпрограммы, либо блоком, задающим
        безымянную подпрограмму. Эта подпрограмма принимает два аргумента <tt>$a</tt> и <tt>$b</tt> и должна возвращать
        отрицательное число, если <tt>$a</tt> &lt; <tt>$b</tt>, нуль, если <tt>$a</tt> = <tt>$b</tt>, и положительное число,
        если <tt>$a</tt> &gt; <tt>$b</tt>. Следующий пример сортирует массив строк без учета регистра символов:</p>

      <div class="code">
<pre class="code">@sorted = sort {uc($a) cmp uc($b)} @array;</pre>
      </div>

      <h4><a name="hsplice">Функция splice</a></h4>

<pre class="syntax"><strong><a name="fsplice">Синтаксис</a></strong>: splice <em>массив</em>, <em>начало</em>, <em>длина</em>, <em>список</em>
<strong>Аргументы</strong>: <em>массив</em>&nbsp;&#151; именованный массив
           <em>начало</em>, <em>длина</em>&nbsp;&#151; числовые выражения
           <em>список</em>&nbsp;&#151; список выражений
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>splice</strong> удаляет элементы <em>массива</em>, начиная с индекса <em>начало</em>
        и в количестве <em>длина</em>. Если задан <em>список</em>, то его элементы вставляются вместо удаленных.
        Функция возвращает список удаленных элементов, а в скалярном контексте&nbsp;&#151; последний удаленный элемент
        или <strong>undef</strong>, если ничего не удалено.</p>
      <p>Если <em>начало</em> отрицательно, то оно отсчитывается от конца массива. Если <em>длина</em> опущена, то удаляются
        элементы до конца массива; если она отрицательна, то она складывается с длиной массива. Если и <em>начало</em>, и
        <em>длина</em> опущены, то удаляются все элементы массива.</p>
      <p>Пример: следующие операторы эквивалентны по своему результату:</p>

      <div class="code">
<pre class="code">push(@a, $x, $y)       splice(@a, @a, 0, $x, $y)
pop(@a)                splice(@a, -1)
shift(@a)              splice(@a, 0, 1)
unshift(@a, $x, $y)    splice(@a, 0, 0, $x, $y)
$a[$x] = $y            splice(@a, $x, 1, $y)</pre>
      </div>

      <h4><a name="hunshift">Функция unshift</a></h4>

<pre class="syntax"><strong><a name="funshift">Синтаксис</a></strong>: unshift <em>массив</em>, <em>список</em>
<strong>Аргументы</strong>: <em>массив</em>&nbsp;&#151; именованный массив
           <em>список</em>&nbsp;&#151; список выражений
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>unshift</strong> добавляет элементы <em>списка</em> в начало <em>массива</em> и возвращает
        количество добавленных элементов. Пример:</p>

      <div class="code">
<pre class="code">@a = (1, 2, 3);
unshift @a, 4, 5;
print @a; # (4, 5, 1, 2, 3)</pre>
      </div>

      <h3><a name="ref6102">6.10.2. Функции работы с ассоциативными массивами</a></h3>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Функция</th>
            <th>Описание</th>
          </tr>
          <tr>
            <td><a href="#fdelete"><tt>delete</tt></a></td>
            <td>Удаляет элемент(ы) массива или ассоциативного массива.</td>
          </tr>
          <tr>
            <td><a href="#feach"><tt>each</tt></a></td>
            <td>Итерация ассоциативных массивов.</td>
          </tr>
          <tr>
            <td><a href="#fexists"><tt>exists</tt></a></td>
            <td>Проверяет наличие элемента в массиве или ассоциативном массиве.</td>
          </tr>
          <tr>
            <td><a href="#fkeys"><tt>keys</tt></a></td>
            <td>Возвращает список ключей ассоциативного массива.</td>
          </tr>
          <tr>
            <td><a href="#fvalues"><tt>values</tt></a></td>
            <td>Возвращает список значений ассоциативного массива.</td>
          </tr>
        </table>
      </div>

      <h4 class="vindent"><a name="hdelete">Функция delete</a></h4>

<pre class="syntax"><strong><a name="fdelete">Синтаксис</a></strong>: delete <em>аргумент</em>
<strong>Аргументы</strong>: <em>аргумент</em>&nbsp;&#151; выражение
<strong>Результат</strong>: значение или список значений</pre>

      <p>Функция <strong>delete</strong> удаляет элемент или вырезку массива или ассоциативного массива,
        заданные <em>аргументом</em> и возвращает их (или <strong>undef</strong>, если ничего не удалено).
        Если удаляются элементы в конце массива, то длина массива соответственно уменьшается; если же
        удаляются элементы в середине массива, то им присваивается неопределенное значение, и размер массива
        не изменяется. Примеры:</p>

      <div class="code">
<pre class="code">@a = (1, 2, 3, 4, 5);
@b = delete @a[1..2];	# @b = (2, 3)
%colors = (black => 0x000000, red => 0xff0000, blue => 0x0000ff, green => 0x008000);
@x = delete @colors{'black', 'red'}; # @x = (0x000000, 0xff0000)</pre>
      </div>

      <h4><a name="heach">Функция each</a></h4>

<pre class="syntax"><strong><a name="feach">Синтаксис</a></strong>: each <em>аргумент</em>
<strong>Аргументы</strong>: <em>аргумент</em>&nbsp;&#151; ассоциативный массив
<strong>Результат</strong>: список (ключ, значение)</pre>

      <p>Функция <strong>each</strong> предназначена для итеративного просмотра ассоциативного массива.
        При каждом вызове она возвращает список (ключ, значение) для очередного элемента <em>аргумента</em>
        (в скалярном контексте возвращается ключ очередного массива). Когда ассоциативный массив просмотрен
        полностью, возвращапример:</p>
        
      <div class="code">
<pre class="code">use Socket;
$remoteaddr = getpeername(SOCK);
($port, $iaddr) = sockaddr_in($remoteaddr);
$remotehostname = gethostbyaddr($iaddr, AF_INET); // имя удаленного хоста
$remoteaddr = inet_ntoa($iaddr); // строковый адрес удаленного хоста</pre>
      </div>
      
      <h4><a name="hgetsockname">Функция getsockname</a></h4>

<pre class="syntax"><strong><a name="fgetsockname">Синтаксис</a></strong>: getsockname <em>сокет</em>
<strong>Аргументы</strong>: <em>сокет</em>&nbsp;&#151; описатель файла
<strong>Результат</strong>: адрес сокета</pre>

      <p>Функция <strong>getsockname</strong> возвращает упакованный адрес локального конца соединения,
        заданого локальным <em>сокетом</em>. Если <em>сокет</em> не имеет соединения, то возникает фатальная
        ошибка. Для распаковки полученного адреса проще всего пользоваться функциями модуля Socket, например:</p>
        
      <div class="code">
<pre class="code">use Socket;
$mysockaddr = getsockname(SOCK);
($port, $iaddr) = sockaddr_in($mysockaddr);
$myhostname = gethostbyaddr($iaddr, AF_INET); // имя локального хоста
$myaddr = inet_ntoa($iaddr); // строковый адрес локального хоста</pre>
      </div>
      
      <h4><a name="hgetsockopt">Функция getsockopt</a></h4>

<pre class="syntax"><strong><a name="fgetsockopt">Синтаксис</a></strong>: getsockopt <em>сокет</em>, <em>уровень</em>, <em>имя</em>
<strong>Аргументы</strong>: <em>сокет</em>&nbsp;&#151; описатель файла
           <em>уровень</em>, <em>имя</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>getsockopt</strong> возвращает текущее значение параметра <em>имя</em> данного <em>сокета</em> или <strong>undef</strong>
        при неудаче. <em>Уровень</em> определяет уровень абстракции, на котором данный параметр определен. Он может принимать значения, имеющие
        следующие символические имена из модуля Socket: SOL_SOCKET (уровень сокетов) и IPPROTO_TCP (уровень TCP/IP). Допустимые
        имена параметров и их значения зависят как от выбранного уровня, так и от операционной системы.</p>
        
      <h4><a name="hlisten">Функция listen</a></h4>

<pre class="syntax"><strong><a name="flisten">Синтаксис</a></strong>: listen <em>сокет</em>, <em>очередь</em>
<strong>Аргументы</strong>: <em>сокет</em>&nbsp;&#151; описатель файла
           <em>очередь</em>&nbsp;&#151; числовое значение
<strong>Результат</strong>: логическое значение</pre>

      <p>Функция <strong>listen</strong> переводит <em>сокет</em> в режим прослушивания установленного соединения.
        Она возвращает истину при успешном соединении и ложь при неудаче.
        Параметр <em>очередь</em> задает максимальный размер очереди отложенных соединений; если он равен SOMAXCONN,
        то он устанавливается максимально возможным для данного типа сокета. Пример см. в описании функции <tt><a href="#fbind">bind</a></tt>.</p>
        
      <h4><a name="hrecv">Функция recv</a></h4>

<pre class="syntax"><strong><a name="frecv">Синтаксис</a></strong>: recv <em>сокет</em>, <em>буфер</em>, <em>длина</em>, <em>флаги</em>
<strong>Аргументы</strong>: <em>сокет</em>&nbsp;&#151; описатель файла
           <em>буфер</em>&nbsp;&#151; скалярная переменная
           <em>длина</em>, <em>флаги</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>recv</strong> принимает данные от указанного <em>сокета</em>. Делается попытка считать
        <em>длину</em> байтов в переменную <em>буфер</em>. Возвращается адрес удаленного сокета или пустая строка,
        если протокол <em>сокета</em> не поддерживает передачу этого адреса. При ошибке возвращается <strong>undef</strong>.
        Допустимые значения <em>флагов</em> зависят от операционной системы. Эта функция предназначена для приема датаграммных
        сообщений по протоколам типа UDP.</p>
        
      <h4><a name="hsend">Функция send</a></h4>

<pre class="syntax"><strong><a name="fsend">Синтаксис</a></strong>: send <em>сокет</em>, <em>сообщение</em>, <em>флаги</em>, <em>приемник</em>?
<strong>Аргументы</strong>: <em>сокет</em>&nbsp;&#151; описатель файла
           <em>сообщение</em>&nbsp;&#151; текстовое выражение
           <em>длина</em>, <em>флаги</em>&nbsp;&#151; числовые выражения
           <em>приемник</em>&nbsp;&#151; адрес сокета
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>send</strong> посылает <em>сообщение</em> удаленному сокету. Если локальный <em>сокет</em> не соединен с удаленным,
        то необходимо явно указать упакованный адрес <em>приемника</em>. Возвращается количество переданных символов; при ошибке возвращается
        <sYFILE.TXT, содержащий следующие строки:</p>
<samp>First<br>
Second<br>
Third</samp>

      <p>Чаще всего связывание переменных используется для установления неявной связи ассоциативных массивов с базами данных,
        но эта тема выходит за пределы нашего справочника.</p>

    </td></tr>
  <tr><td><div id="divFooter"></div></td></tr>
</table>
</body>
</html>
 ђ”H4ЎU  б<      Xr Нo  Xr Нo  °”H4ЎU  °”H4ЎU  , то этот список рассматривается как набор правил,
        управляющих списком импортируемых имен. Правила обрабатываются слева направо в соответствии со следующей таблицей:</p>

      <div class="indent">
        <table border="1" cellspacing="0" cellpadding="5">
          <tr>
            <th>Конструкция</th>
            <th>Значение</th>
          </tr>
          <tr>
            <td><tt><em>name</em></tt></td>
            <td>Добавить имя <tt><em>name</em></tt>.</td>
          </tr>
          <tr>
            <td><tt>!<em>name</em></tt></td>
            <td>Удалить имя <tt><em>name</em></tt>.</td>
          </tr>
          <tr>
            <td><tt>:DEFAULT</tt></td>
            <td>Добавить все имена из списка <tt>@EXPORT</tt>.</td>
          </tr>
          <tr>
            <td><tt>!:DEFAULT</tt></td>
            <td>Удалить все имена из списка <tt>@EXPORT</tt>.</td>
          </tr>
          <tr>
            <td><tt>:<em>tag</em></tt></td>
            <td>Добавить все имена из списка <tt>%EXPORT_TAGS{<em>tag</em>}</tt>.</td>
          </tr>
          <tr>
            <td><tt>!:<em>tag</em></tt></td>
            <td>Удалить все имена из списка <tt>%EXPORT_TAGS{<em>tag</em>}</tt>.</td>
          </tr>
          <tr>
            <td><tt>/<em>pattern</em>/</tt></td>
            <td>Добавить все имена из списков <tt>@EXPORT</tt> и <tt>@EXPORT_OK</tt>, соответствующие образцу <tt><em>pattern</em></tt>.</td>
          </tr>
          <tr>
            <td><tt>!/<em>pattern</em>/</tt></td>
            <td>Удалить все имена из списков <tt>@EXPORT</tt> и <tt>@EXPORT_OK</tt>, соответствующие образцу <tt><em>pattern</em></tt>.</td>
          </tr>
        </table>
      </div>

      <p>Если список начинается с операции удаления, то считается, что ей предшествует операция :<tt>DEFAULT</tt>.</p>

      <p>Пусть наш модуль Sample содержит следующие операторы:</p>

      <div class="code">
<pre class="code">@EXPORT = qw(A1 A2 A3 A4 A5);
@EXPORT_OK = qw(B1 B2 B3 B4 B5);
%EXPORT_TAGS = (T1 =&gt; [qw(A1 A2 B1 B2)], T2 =&gt; [qw(A1 A2 B3 B4)]);</pre>
      </div>

      <p>Тогда программа, обращающаяся к Sample, могла бы содержать оператор</p>

      <div class="code">
<pre class="code">use Sample qw(:DEFAULT :T2 !B3 B5 /^.1/);
</pre>
      </div>

      <p class="noindent">который в данном случае эквивалентен оператору</p>

      <div class="code">
<pre class="code">use Sample qw(A1 A2 A3 A4 A5 B4 B5 B1);
</pre>
      </div>

      <p>Для отладки подобных конструкций удобно добавить в свою программу оператор <code>BEGIN { $Exporter::Verbose=1 }</code>,
        который выводит на консоль информацию об обработке операций импорта.</p>

      <p>Помимо описанных массивов модуль Exporter содержит несколько дополнительных возможностей, облегчающих управление экспортом символов.</p>

      <p>Поскольку все символы, перечисленные в <tt>%EXPORT_TAGS</tt>, обязаны присутствовать в <tt>@EXPORT</tt> или <tt>@EXPORT_OK</tt>, предусмотрены
        две функции <tt>export_tags</tt> и <tt>export_ok_tags</tt>, позволяющие легко добавлять символы в эти массивы. Пример:</p>

      <div class="code">
<pre class="code">%EXPORT_TAGS = (XXX =&gt; [qw(aa bb cc)], YYY =&gt; [qw(cc dd ee)]);
Exporter::export_tags('XXX');    # добавляет aa, bb и cc в @EXPORT
Exporter::export_ok_tags('YYY'); # добавляет cc, dd и ee в @EXPORT_OK</pre>
      </div>

      <p>Функция <tt>use()</tt> при проверке версии модуля вызывает метод <tt>$module_name-&gt;require_version($value)</tt>.
        В модуле Exporter этот метод реализован и проверяет переменную модуля <tt>$VERSION</tt>. При ее использовании нужно
        помнить, что версия рассматривается как плавающее число и потому 1.10 меньше, чем 1.9. Поэтому рекомендуется использовать
        номера версий с двумя цифрами после десятичной точки вида 1.09.</p>

      <p>Кроме того, Exporter содержит еще один метод, который используется в тех случаях, когда метод <tt>import</tt> модуля Exporter не
        может быть вызван напрямую. Этот метод имеет вид</p>

<pre class="syntax">MyPackage-&gt;export_to_level($level, $package, @what);</pre>

      <p class="noindent">где <tt>$level</tt>&nbsp;&#151; целое число, задающее уровень экспорта, т.&nbsp;е. количество модулей в стеке вызовов,
        на которое нужно подняться, а <tt>@what</tt>&nbsp;&#151; массив экспортируемых символов, обычно <tt>@_</tt>. Параметр <tt>$package</tt>
        зарезервирован для будущих версий. Пусть, например, наш модуль Sample содержит строки</p>

      <div class="code">
<pre class="code">@EXPORT_OK = qw($b);
sub import { $Sample::b = 1; Sample-&gt;export_to_level(1, @_); }</pre>
      </div>

      <p>Тогда оператор <code>use Sample ($b)</code> экспортирует переменную <tt>$Sample::b</tt> на один уровень вверх, т.&nbsp;е.
        в программу или модуль, вызвавшие модуль Sample.</p>

      <p>Наконец, Exporter позволяет нам явно запретить экспорт каких-либо символов. Имена таких символов должны быть указаны в
        массиве <tt>@EXPORT_FAIL</tt>. При попытке импортировать эти символы Exporter вызывает оператор</p>

      <div class="code">
<pre class="code">@failed_symbols = $module_name-&gt;export_fail(@failed_symbols);</pre>
      </div>

      <p>Если список, возвращаемый методом <tt>export_fail</tt>, пуст, то запрошенные символы экспортируются. В противном случае
        для каждого символа в этом списке генерируется соответствующее сообщение об ошибке. Мы можем переопределить в своем модуле метод
        <tt>export_fail</tt> или воспользоваться его реализацией по умолчанию, которая просто возвращает переданный ей список.</p>

    </td></tr>
  <tr><td><div id="divFooter"></div></td></tr>
</table>
</body>
</html>
 «H4ЎU  &      (r Нo  (r Нo  ђ«H4ЎU  ђ«H4ЎU  агальский</td>
            <td>tl</td>
          </tr>
          <tr>
            <td>Дзонг-кэ</td>
            <td>dz</td>
            <td>Таджикский</td>
            <td>tg</td>
          </tr>
          <tr>
            <td>Зулу</td>
            <td>zu</td>
            <td>Тайский (сиамский)</td>
            <td>th</td>
          </tr>
          <tr>
            <td>Иврит</td>
            <td>he</td>
            <td>Тамильский</td>
            <td>ta</td>
          </tr>
          <tr>
            <td>Идиш</td>
            <td>yi</td>
            <td>Татарский</td>
            <td>tt</td>
          </tr>
          <tr>
            <td>Индонезийский</td>
            <td>id</td>
            <td>Тви</td>
            <td>tw</td>
          </tr>
          <tr>
            <td>Интерлингва</td>
            <td>ia</td>
            <td>Телугу</td>
            <td>te</td>
          </tr>
          <tr>
            <td>Интерлингве</td>
            <td>ie</td>
            <td>Тибетский</td>
            <td>bo</td>
          </tr>
          <tr>
            <td>Ирландский</td>
            <td>ga</td>
            <td>Тигринья</td>
            <td>ti</td>
          </tr>
          <tr>
            <td>Исландский</td>
            <td>is</td>
            <td>Тонганский</td>
            <td>to</td>
          </tr>
          <tr>
            <td>Испанский
              <ul class="sublang">
                <li>Аргентина</li>
                <li>Боливия</li>
                <li>Венесуэла</li>
                <li>Гватемала</li>
                <li>Гондурас</li>
                <li>Доминиканская р-ка</li>
                <li>Испания</li>
                <li>Колумбия</li>
                <li>Коста-Рика</li>
                <li>Мексика</li>
                <li>Никарагуа</li>
                <li>Панама</li>
                <li>Парагвай</li>
                <li>Перу</li>
                <li>Пуэрто-Рико</li>
                <li>Сальвадор</li>
                <li>Уругвай</li>
                <li>Чили</li>
                <li>Эквадор</li>
              </ul>
            </td>
            <td>es
              <ul class="sublang">
                <li>es-ar</li>
                <li>es-bo</li>
                <li>es-ve</li>
                <li>es-gt</li>
                <li>es-hn</li>
                <li>es-do</li>
                <li>es</li>
                <li>es-co</li>
                <li>es-cr</li>
                <li>es-mx</li>
                <li>es-ni</li>
                <li>es-pa</li>
                <li>es-py</li>
                <li>es-pe</li>
                <li>es-pr</li>
                <li>es-sv</li>
                <li>es-uy</li>
                <li>es-cl</li>
                <li>es-ec</li>
              </ul>
            </td>
            <td>Тсонга (шангаан)</td>
            <td>ts</td>
          </tr>
          <tr>
            <td>Итальянский
              <ul class="sublang">
                <li>Италия</li>
                <li>Швейцария</li>
              </ul>
            </td>
            <td>it
              <ul class="sublang">
                <li>it</li>
                <li>it-ch</li>
              </ul>
            </td>
            <td>Турецкий</td>
            <td>tr</td>
          </tr>
          <tr>
            <td>Йоруба</td>
            <td>yo</td>
            <td>Туркменский</td>
            <td>tk</td>
          </tr>
          <tr>
            <td>Казахский</td>
            <td>kk</td>
            <td>Узбекский</td>
            <td>uz</td>
          </tr>
          <tr>
            <td>Каннада</td>
            <td>kn</td>
            <td>Уйгурский</td>
            <td>ug</td>
          </tr>
          <tr>
            <td>Каталанский</td>
    