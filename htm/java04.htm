<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Author" content="Юрий Лукач">
<meta name="Description" content="Справочник Веб-разработчика: современные технологии WWW">
<meta name="Keywords" content="WWW, Веб, разработка, программирование, HTML, DHTML, CSS, Java, JavaScript, CGI, PERL, ASP, XML, XSL, VML, VRML">
<title>WDH: Java - Преобразования типов</title>
<link rel="Prev" href="java03.htm" title="Типы, значения и переменные">
<link rel="Next" href="java05.htm" title="Идентификаторы и имена">
<link rel="Copyright" href="cpyright.htm" title="Сведения об авторских правах">
<link rev="Made" href="mailto:yury@suncloud.ru" title="Обратная связь">
<script type="text/javascript" src="global/load.js"></script>
<script type="text/javascript" src="global/link.js"></script>
</head>

<body onLoad="initDoc(); addBanner(true)">
<table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin: 0">
  <tr><td><div id="divHeader"></div></td></tr>
  <tr><td id="tdBanner" style="text-align: center"><script type="text/javascript">addBanner(false);</script></td></tr>
  <tr><td>

      <h2><a name="ref54">Глава 5.4. Преобразования типов</a></h2>

      <h3><a name="ref541">5.4.1. Виды преобразований</a></h3>

      <p>Каждое выражение в Java имеет тип, который определяется структурой выражения и типами составляющих
        его операндов (констант, переменных и методов). Однако, иногда нам может потребоваться явное
        преобразование выражения в другой тип. Кроме того, в некоторых ситуациях исполняющая система
        Java сама неявно проводит такие преобразования.</p>

      <p><em>Преобразование типа</em> Т<sub>1</sub> в тип T<sub>2</sub> позволяет выражению типа T<sub>1</sub>
        трактоваться в период компиляции как выражение типа T<sub>2</sub>. В одних случаях это чисто
        синтаксическая конструкция, не влияющая на генерируемый код, в других преобразование типа требует
        дополнительных действий в период выполнения по изменению значения выражения или дополнительных
        проверок правильности применяемого преобразования. Примеры:</p>

      <ul>
        <li>Преобразование типа <strong>int</strong> в тип <strong>long</strong> требует во время выполнения
          программы расширения знака 32-битового целого значения до 64-битового целого. Потери информации
          при этом не происходит.</li>
        <li>Преобразование типа <strong>float</strong> в тип <strong>long</strong> требует во время
          выполнения программы нетривиального преобразования 32-битового плавающего значения в 64-битовое
          целое. В зависимости от исходного значения может произойти или не произойти потеря информации.</li>
        <li>Преобразование типа <tt>Thread</tt> в тип <tt>Object</tt> не требует никаких действий: поскольку
          класс <tt>Thread</tt> является потомком класса <tt>Object</tt>, любая ссылка на объект типа
          <tt>Thread</tt> автоматически является ссылкой на объект типа <tt>Object</tt>.</li>
        <li>Преобразование типа <tt>Object</tt> в тип <tt>Thread</tt> требует проверки в период исполнения.
          Если преобразуемая ссылка действительно является ссылкой на объект типа <tt>Thread</tt>, то
          она возвращается как результат преобразования, в противном случае генерируется исключение.</li>
      </ul>

      <p>Далее в этой главе приведена классификация всех возможных преобразований типов, а затем классификация
        контекстов в которой они могут использоваться.</p>

      <h4><a name="ref5411">5.4.1.1. Расширяющие преобразования чисел</a></h4>

      <p><em>Расширяющие преобразования чисел</em>&nbsp;&#151; это преобразования числового типа в &quot;больший&quot;
        числовой тип, которые считаются безопасными, т.&nbsp;к. не приводят к потере величины преобразуемого
        значения. Такими преобразованиями в Java являются:</p>

      <ul>
        <li>преобразования <strong>byte</strong> в <strong>short</strong>, <strong>int</strong>, <strong>long</strong>,
          <strong>float</strong> и <strong>double</strong>;</li>
        <li>преобразования <strong>short</strong> в <strong>int</strong>, <strong>long</strong>, <strong>float</strong>
          и <strong>double</strong>;</li>
        <li>преобразования <strong>char</strong> в <strong>int</strong>, <strong>long</strong>, <strong>float</strong>
          и <strong>double</strong>;</li>
        <li>преобразования <strong>int</strong> в <strong>long</strong>, <strong>float</strong> и <strong>double</strong>;</li>
        <li>преобразования <strong>long</strong> в <strong>float</strong> и <strong>double</strong>;</li>
        <li>преобразования <strong>float</strong> в <strong>double</strong>.</li>
      </ul>

      <p>В действительности, преобразование целого значения в плавающее может привести к потере точности,
        т.&nbsp;е. к потере значащих цифр. Так, следующий пример</p>

      <div class="code">
<pre class="code">class Test {
  public static void main(String args[]) {
    int bigNumber = 1234567890;
    float approximate = bigNumber;
    System.out.println(approximate);
  }
}</pre>
      </div>

      <p class="noindent">выведет на экран строку <samp>1234567936</samp>. Это связано с тем, что при
        преобразовании <strong>int</strong> в <strong>float</strong> результирующее значение равно 1.2345679E9
        из-за того, что мантисса чисел типа <strong>float</strong> вмещает только 8 десятичных цифр
        (здесь для правильной работы следует использовать преобразование к типу <strong>double</strong>).
        Тем не менее, исполняющая система никогда не генерирует ошибок при выполнении перечисленных
        преобразований.</p>

      <h4><a name="ref5412">5.4.1.2. Сужающие преобразования чисел</a></h4>

      <p><em>Сужающие преобразования чисел</em>&nbsp;&#151; это преобразования числового типа в &quot;меньший&quot;
        числовой тип, которые могут привести как к потере величины, так и к потере точности. Такими
        преобразованиями в Java являются:</p>

      <ul>
        <li>преобразования <strong>byte</strong> в <strong>char</strong>;</li>
        <li>преобразования <strong>short</strong> в <strong>byte</strong> и <strong>char</strong>;</li>
        <li>преобразования <strong>int</strong> в <strong>byte</strong>, <strong>short</strong> и <strong>char</strong>;</li>
        <li>преобразования <strong>long</strong> в <strong>byte</strong>, <strong>short</strong>, <strong>int</strong>
          и <strong>char</strong>;</li>
        <li>преобразования <strong>float</strong> в <strong>byte</strong>, <strong>short</strong>, <strong>int</strong>,
          <strong>long</strong> и <strong>char</strong>;</li>
        <li>преобразования <strong>double</strong> в <strong>byte</strong>, <strong>short</strong>,
          <strong>int</strong>, <strong>long</strong>, <strong>float</strong> и <strong>char</strong>;</li>
      </ul>

      <p>Мы не будем здесь подробно рассматривать правила, по которым происходят эти преобразования,
        поскольку интуитивно они понятны, а формально достаточно громоздки. При их применении важно
        помнить, что Java, в отличие от других языков, не генерирует ошибок при переполнении (overflow)
        или потере значения (underflow), поэтому контроль за корректностью преобразований полностью
        ложится на программиста.</p>

      <h4><a name="ref5413">5.4.1.3. Расширяющие преобразования ссылок</a></h4>

      <p><em>Расширяющие преобразования ссылок</em>&nbsp;&#151; это преобразования производных ссылочных
        типов в типы их предков, которые не требуют никаких действий на этапе исполнения и никогда не
        генерируют ошибок. Такими преобразованиями в Java являются:</p>

      <ul>
        <li>преобразование любого класса или интерфейса в его предка (в частности, в тип <tt>Object</tt>);</li>
        <li>преобразование класса в интерфейс, который он реализует;</li>
        <li>преобразование любого массива в тип <tt>Object</tt> или тип <tt>Cloneable</tt>;</li>
        <li>преобразование массива типа S[] в массив типа T[], если S и T&nbsp;&#151; ссылочные типы,
          и преобразование S в T является расширяющим;</li>
        <li>преобразование нулевого типа в любой ссылочной тип.</li>
      </ul>

      <h4><a name="ref5414">5.4.1.4. Сужающие преобразования ссылок</a></h4>

      <p><em>Сужающие преобразования ссылок</em>&nbsp;&#151; это преобразования производных ссылочных
        типов в типы их потомков. Эти преобразования требуют проверки своей легитимности на этапе исполнения
        и могут генерировать исключение <tt>ClassCastException</tt>. Такими преобразованиями в Java
        являются:</p>

      <ul>
        <li>преобразование любого класса в его потомка (в частности, преобразование типа <tt>Object</tt>
          в любой другой класс);</li>
        <li>преобразование класса в интерфейс, когда класс не является финальным и не реализует данный
          интерфейс (в частности, преобразование типа <tt>Object</tt> в любой интерфейс);</li>
        <li>преобразование типа <tt>Object</tt> в любой массив;</li>
        <li>преобразование любого интерфейса в класс, который не является финальным;</li>
        <li>преобразование любого интерфейса в класс, который является финальным и реализует данный
          интерфейс;</li>
        <li>преобразование интерфейса J в интерфейс K, когда J не является потомком K, и не существует
          метода, декларированного и в J, и в K с одинаковой сигнатурой, но разными типами результата;</li>
        <li>преобразование массива типа S[] в массив типа T[], если S и T&nbsp;&#151; ссылочные типы,
          и преобразование S в T является сужающим.</li>
      </ul>

      <h4><a name="ref5415">5.4.1.5. Преобразования в строки</a></h4>

      <p>Любое выражение в Java, включая <strong>null</strong>, может быть преобразовано в тип <tt>String</tt>.</p>

      <h4><a name="ref5416">5.4.1.6. Недопустимые преобразования</a></h4>

      <p>Следующие преобразования типов в Java запрещены:</p>

      <ul>
        <li>преобразование любого ссылочного типа в любой примитивный тип;</li>
        <li>преобразование любого примитивного типа в любой ссылочной тип, кроме типа <tt>String</tt>;</li>
        <li>преобразование нулевого типа в любой примитивный тип;</li>
        <li>преобразования в нулевой тип или тип <strong>boolean</strong>;</li>
        <li>преобразования типа <strong>boolean</strong> в любой другой тип, кроме типа <tt>String</tt>;</li>
        <li>преобразование одного класса в другой, если ни один из них не является предком другого (кроме
          преобразования в тип <tt>String</tt>);</li>
        <li>преобразование класса в интерфейс, если класс является финальным и не реализует данный интерфейс;</li>
        <li>преобразование класса в массив, если класс отличен от <tt>Object</tt>;</li>
        <li>преобразование интерфейс в класс, который является финальным и не реализует данный интерфейс
          (кроме преобразования в тип <tt>String</tt>);</li>
        <li>преобразование интерфейса J в интерфейс K, если существует метод, декларированный и в
          J, и в K с одинаковой сигнатурой, но разными типами результата;</li>
        <li>преобразование массива в класс, отличный от <tt>Object</tt> и <tt>String</tt>;</li>
        <li>преобразование массива в интерфейс, отличный от <tt>Cloneable</tt>;</li>
        <li>преобразование массива типа S[] в массив типа T[], если преобразование S в T является запрещенным</li>
      </ul>

      <h3><a name="ref542">5.4.2. Контексты преобразований</a></h3>

      <h4><a name="ref5421">5.4.2.1. Преобразование при присваивании</a></h4>

      <p><em>Преобразование при присваивании</em> происходит, когда значение выражения присваивается
        переменной. При этом тип выражения преобразуется к типу переменной. При присваивании всегда
        возможны расширяющие преобразования типов (как числовых, так и ссылочных). Сужающее преобразование
        возможно только при соблюдении следующих условий:</p>

      <ul>
        <li>переменная имеет тип <strong>byte</strong>, <strong>short</strong> или <strong>char</strong>;</li>
        <li>значением выражения является константа типа <strong>int</strong>, которая попадает в диапазон
          возможных значений переменной.</li>
      </ul>

      <p>Например, оператор <code>byte x = 123;</code> допустим, поскольку константа 123 (имеющая тип
        <strong>int</strong>) лежит в диапазоне допустимых значений типа <strong>byte</strong>.</p>

      <p>Если тип выражения не может быть преобразован к типу переменной, то компилятор генерирует ошибку.
        В остальных случаях мы говорим, что тип выражения <em>совместим по присваиванию</em> с типом
        переменной. Так, следующий фрагмент</p>

      <div class="code">
<pre class="code">short s = 123;
char c = s;		// генерирует ошибку компиляции</pre>
      </div>

      <p class="noindent">приведет к генерации ошибки, поскольку типы <strong>char</strong> и <strong>short</strong>
        несовместимы по присваиванию согласно данных выше определениям (первый реализован 16-битовыми
        словами без знака, а второй&nbsp;&#151; со знаком).</p>

      <h4><a name="ref5422">5.4.2.2. Преобразование аргументов метода</a></h4>

      <p><em>Преобразование аргументов метода</em> происходит, когда фактические значения аргументов
        преобразуется к типу параметров метода или конструктора при его вызове. При этом всегда возможны
        расширяющие преобразования типов (как числовых, так и ссылочных) и недопустимы сужающие преобразования.
        Причины последнего запрета можно пояснить следующим примером:</p>

      <div class="code">
<pre class="code">class Test {
  static int m(byte a, int b) { return a + b; }
  static int m(short a, short b) { return a - b; }
  public static void main(String args[]) {
    System.out.println(<strong>m(1, 2)</strong>);	// генерирует ошибку компиляции
  }
}</pre>
      </div>

      <p>Здесь класс <tt>Test</tt> содержит два одноименных метода, которые различаются только типами
        параметров. Если бы сужающие преобразования аргументов были в Java разрешены, то исполняющей
        системе пришлось бы определять, к какому из этих методов относится вызов <code>m(1, 2)</code>.
        Чтобы избежать подобных двусмысленностей, разработчики языка решили проблему радикально: они
        запретили подобные вызовы методов. В данной ситуации для вызова, к примеру, первого метода мы
        должны явно указать тип первого операнда (второй по умолчанию уже имеет тип <strong>int</strong>),
        а именно <code>m((byte)1, 2)</code>.</p>

      <h4><a name="ref5423">5.4.2.3. Преобразование в строку</a></h4>

      <p><em>Преобразование в строку</em> происходит только в одном случае: когда бинарная операция
        <tt>+</tt> применяется к двум операндам, один из которых имеет тип <tt>String</tt>. В этой ситуации
        второй операнд также преобразуется к типу <tt>String</tt>, и результатом операции является конкатенация
        полученных строк. Подробнее этот процесс описан в <a href="java14.htm">гл. 5.14</a>.</p>

      <h4><a name="ref5424">5.4.2.4. Явное преобразование типа</a></h4>

      <p><em>Явное преобразование типа</em> происходит, когда к операнду явно применяется операция приведения
        типа (type cast). В этой ситуации могут применяться все описанные выше виды преобразований типов,
        кроме преобразования в строку. Попытка явного преобразования к типу, отмеченная выше, как запрещенная,
        вызовет ошибку компиляции. Кроме того, на этапе выполнения возможна генерация исключения ClassCastException,
        если заданное преобразование недопустимо.</p>

      <h3><a name="ref543">5.4.3. Преобразования типов числовых операндов</a></h3>

      <p>Преобразование типов в процессе вычисления числовых выражений имеет ряд особенностей. Они сводятся
        к двум случаям: преобразования операндов в унарных операциях и в бинарных операциях.</p>

      <p>Перед выполнением унарной операции:</p>

      <ul>
        <li>если операнд имеет тип <strong>byte</strong>, <strong>short</strong> или <strong>char</strong>,
          он преобразуется к типу <strong>int</strong>;</li>
        <li>в остальных случаях его тип не изменяется.</li>
      </ul>

      <p>Перед выполнением бинарной операции:</p>

      <ul>
        <li>если один из операндов типа <strong>double</strong>, то второй также преобразуется к типу
          <strong>double</strong>;</li>
        <li>в противном случае, если один из операндов типа <strong>float</strong>, то второй также
          преобразуется к типу <strong>float</strong>;</li>
        <li>в противном случае, если один из операндов типа <strong>long</strong>, то второй также преобразуется
          к типу <strong>long</strong>;</li>
        <li>в противном случае, оба операнда преобразуются к типу <strong>int</strong>.</li>
      </ul>

    </td></tr>
  <tr><td><div id="divFooter"></div></td></tr>
</table>
</body>
</html>
