<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Author" content="Юрий Лукач">
<meta name="Description" content="Справочник Веб-разработчика: современные технологии WWW">
<meta name="Keywords" content="WWW, Веб, разработка, программирование, HTML, DHTML, CSS, Java, JavaScript, CGI, PERL, ASP, XML, XSL, VML, VRML">
<title>WDH: PERL - Встроенные функции</title>
<link rel="Prev" href="perl08.htm" title="Классы и объекты">
<link rel="Next" href="perl10.htm" title="Встроенные функции (продолжение)">
<link rel="Copyright" href="cpyright.htm" title="Сведения об авторских правах">
<link rev="Made" href="mailto:yury@suncloud.ru" title="Обратная связь">
<script type="text/javascript" src="global/load.js"></script>
<script type="text/javascript" src="global/link.js"></script>
</head>

<body onLoad="initDoc(); addBanner(true)">
<table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin: 0">
  <tr><td><div id="divHeader"></div></td></tr>
  <tr><td id="tdBanner" style="text-align: center"><script type="text/javascript">addBanner(false);</script></td></tr>
  <tr><td>

      <h2><a name="ref69">Глава 6.9. Встроенные функции</a></h2>

      <p>В этой и следующих главах описаны все встроенные функции языка PERL, которые поддерживаются и в Unix,
        и в Windows. Для удобства пользования мы разбили их на следующие группы:</p>
      <ul>
        <li><a href="#ref691">числовые функции</a>;</li>
        <li><a href="#ref692">строковые функции</a>;</li>
        <li><a href="#ref693">прочие скалярные функции</a>;</li>
        <li><a href="#ref694">функции работы с регулярными выражениями</a>;</li>
        <li><a href="perl10.htm#ref6101">функции работы с массивами и списками</a>;</li>
        <li><a href="perl10.htm#ref6102">функции работы с ассоциативными массивами</a>;</li>
        <li><a href="perl10.htm#ref6103">функции работы с временем</a>;</li>
        <li><a href="perl10.htm#ref6104">прочие функции общего назначения</a>;</li>
        <li><a href="perl11.htm#ref6111">функции ввода-вывода</a>;</li>
        <li><a href="perl11.htm#ref6112">функции форматирования ввода-вывода</a>;</li>
        <li><a href="perl11.htm#ref6113">функции управления файлами</a>;</li>
        <li><a href="perl11.htm#ref6114">функции управления каталогами</a>;</li>
        <li><a href="perl12.htm#ref6121">функции управления процессами</a>;</li>
        <li><a href="perl12.htm#ref6122">функции управления сокетами</a>;</li>
        <li><a href="perl12.htm#ref6123">информационные функции</a>.</li>
      </ul>
      <p>Перечень всех встроенных функций языка PERL приведен в <a href="perlfunc.htm">Приложении 21</a>.</p>

      <h3><a name="ref691">6.9.1. Числовые функции</a></h3>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Функция</th>
            <th>Описание</th>
          </tr>
          <tr>
            <td><a href="#fabs"><tt>abs</tt></a></td>
            <td>Абсолютная величина числа.</td>
          </tr>
          <tr>
            <td><a href="#fatan2"><tt>atan2</tt></a></td>
            <td>Арктангенс частного.</td>
          </tr>
          <tr>
            <td><a href="#fcos"><tt>cos</tt></a></td>
            <td>Косинус числа.</td>
          </tr>
          <tr>
            <td><a href="#fexp"><tt>exp</tt></a></td>
            <td>Экспонента числа.</td>
          </tr>
          <tr>
            <td><a href="#fint"><tt>int</tt></a></td>
            <td>Целая часть числа.</td>
          </tr>
          <tr>
            <td><a href="#flog"><tt>log</tt></a></td>
            <td>Натуральный логарифм числа.</td>
          </tr>
          <tr>
            <td><a href="#frand"><tt>rand</tt></a></td>
            <td>Генератор случайных чисел.</td>
          </tr>
          <tr>
            <td><a href="#fsin"><tt>sin</tt></a></td>
            <td>Синус числа.</td>
          </tr>
          <tr>
            <td><a href="#fsqrt"><tt>sqrt</tt></a></td>
            <td>Квадратный корень из числа.</td>
          </tr>
          <tr>
            <td><a href="#fsrand"><tt>srand</tt></a></td>
            <td>Инициализация генератора случайных чисел.</td>
          </tr>
        </table>
      </div>

      <h4 class="vindent"><a name="habs">Функция abs</a></h4>

<pre class="syntax"><strong><a name="fabs">Синтаксис</a></strong>: abs <em>число</em>
<strong>Аргументы</strong>: <em>число</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>abs</strong> возвращает абсолютную величину <em>числа</em>. Если аргумент опущен,
        то <em>число</em> принимается равным значению переменной <tt>$_</tt>. Примеры:</p>

      <div class="code">
<pre class="code">print abs 2;	// 2
print abs -2;	// 2</pre>
      </div>

      <h4><a name="hatan2">Функция atan2</a></h4>

<pre class="syntax"><strong><a name="fatan2">Синтаксис</a></strong>: atan2 <em>число1</em>, <em>число2</em>
<strong>Аргументы</strong>: <em>число1</em>, <em>число2</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>atan2</strong> возвращает арктангенс частного от деления <em>числа1</em> на <em>число2</em>.
        Результат находится в диапазоне от -&pi; до +&pi; и соответствует величине угла в радианах
        между осью абсцисс и вектором до точки с координатами (<em>число2</em>, <em>число1</em>). Примеры:</p>

      <div class="code">
<pre class="code">$x = atan2 -0, -1;	# x равно -3.14159265358979
$x = atan2 -1, 0;	# x равно -1.5707963267949
$x = atan2 0, 1;	# x равно 0
$x = atan2 1, 1;	# x равно 0.785398163397448
$x = atan2 1, 0;	# x равно 1.5707963267949
$x = atan2 0, -1;	# x равно 3.14159265358979</pre>
      </div>

      <h4><a name="hcos">Функция cos</a></h4>

<pre class="syntax"><strong><a name="fcos">Синтаксис</a></strong>: cos <em>число</em>
<strong>Аргументы</strong>: <em>число</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>cos</strong> возвращает косинус <em>числа</em>. Если аргумент опущен,
        то <em>число</em> принимается равным значению переменной <tt>$_</tt>. Примеры:</p>

      <div class="code">
<pre class="code">$pi = atan2 0, -1;
$x = cos 0;     # x равно 1
$x = cos $pi/2; # x равно 6e-17 (почти 0)
$x = cos $pi;   # x равно -1</pre>
      </div>

      <h4><a name="hexp">Функция exp</a></h4>

<pre class="syntax"><strong><a name="fexp">Синтаксис</a></strong>: exp <em>число</em>
<strong>Аргументы</strong>: <em>число</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>exp</strong> возвращает экспоненту <em>числа</em>. Если аргумент опущен,
        то <em>число</em> принимается равным значению переменной <tt>$_</tt>.  Если <em>число</em> больше 709.78,
        то возвращается 1.#INF. Пример:</p>

      <div class="code">
<pre class="code">print exp 1;  # 2.71828182845905</pre>
      </div>

      <h4><a name="hint">Функция int</a></h4>

<pre class="syntax"><strong><a name="fint">Синтаксис</a></strong>: int <em>число</em>
<strong>Аргументы</strong>: <em>число</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>int</strong> возвращает целую часть <em>числа</em>. Если аргумент опущен,
        то <em>число</em> принимается равным значению переменной <tt>$_</tt>. Пример:</p>

      <div class="code">
<pre class="code">print int 1.5;   # 1
print int -1.5;  # -1</pre>
      </div>

      <h4><a name="hlog">Функция log</a></h4>

<pre class="syntax"><strong><a name="flog">Синтаксис</a></strong>: log <em>число</em>
<strong>Аргументы</strong>: <em>число</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>log</strong> возвращает натуральный логарифм <em>числа</em>. Если аргумент опущен,
        то <em>число</em> принимается равным значению переменной <tt>$_</tt>. Если аргумент меньше или равен нулю,
        то возникает фатальная ошибка исполнения. Пример:</p>

      <div class="code">
<pre class="code">print log 2.71828182845905; # 1</pre>
      </div>

      <h4><a name="hrand">Функция rand</a></h4>

<pre class="syntax"><strong><a name="frand">Синтаксис</a></strong>: rand <em>число</em>
<strong>Аргументы</strong>: <em>число</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>rand</strong> возвращает случайное число, большее или равное нулю и меньшее <em>числа</em>,
        которое должно быть положительным. Если аргумент опущен, то <em>число</em> принимается равным 1. Если функция
        <tt><a href="#fsrand">srand()</a></tt> еще не вызывалась, то автоматически вызывает ее.</p>

      <h4><a name="hsin">Функция sin</a></h4>

<pre class="syntax"><strong><a name="fsin">Синтаксис</a></strong>: sin <em>число</em>
<strong>Аргументы</strong>: <em>число</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>sin</strong> возвращает синус <em>числа</em>. Если аргумент опущен,
        то <em>число</em> принимается равным значению переменной <tt>$_</tt>. Примеры:</p>

      <div class="code">
<pre class="code">$pi = atan2 0, -1;
$x = sin 0;      # x равно 0
$x = sin $pi/2;  # x равно 1
$x = sin -$pi/2; # x равно -1</pre>
      </div>

      <h4><a name="hsqrt">Функция sqrt</a></h4>

<pre class="syntax"><strong><a name="fsqrt">Синтаксис</a></strong>: sqrt <em>число</em>
<strong>Аргументы</strong>: <em>число</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>sqrt</strong> возвращает квадратный корень из <em>числа</em>. Если аргумент опущен,
        то <em>число</em> принимается равным значению переменной <tt>$_</tt>. Если аргумент меньше или равен нулю,
        то возникает фатальная ошибка исполнения. Пример:</p>

      <div class="code">
<pre class="code">print sqrt 2; # 1.4142135623731</pre>
      </div>

      <h4><a name="hsrand">Функция srand</a></h4>

<pre class="syntax"><strong><a name="fsrand">Синтаксис</a></strong>: srand <em>число</em>
<strong>Аргументы</strong>: <em>число</em>&nbsp;&#151; числовое выражение
</pre>

      <p>Функция <strong>srand</strong> инициализирует генератор случайных чисел <tt><a href="#frand">rand()</a></tt>.
        Если ее аргумент опущен, то <em>число</em> генерируется исполняющей системой. Начиная с PERL 5.004, явный вызов
        этой функции не нужен, т.&nbsp;к. теперь она автоматически вызывается функцией <tt>rand()</tt> при первом обращении к ней.</p>

      <h3><a name="ref692">6.9.2. Строковые функции</a></h3>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Функция</th>
            <th>Описание</th>
          </tr>
          <tr>
            <td><a href="#fchomp"><tt>chomp</tt></a></td>
            <td>Удаляет концевой разделитель записей.</td>
          </tr>
          <tr>
            <td><a href="#fchop"><tt>chop</tt></a></td>
            <td>Удаляет последний символ строки.</td>
          </tr>
          <tr>
            <td><a href="#fcrypt"><tt>crypt</tt></a></td>
            <td>Кодирует текст.</td>
          </tr>
          <tr>
            <td><a href="#findex"><tt>index</tt></a></td>
            <td>Возвращает первую слева позицию заданной подстроки.</td>
          </tr>
          <tr>
            <td><a href="#flc"><tt>lc</tt></a></td>
            <td>Преобразует строку в строчные буквы.</td>
          </tr>
          <tr>
            <td><a href="#flcfirst"><tt>lcfirst</tt></a></td>
            <td>Преобразует первый символ строки в строчную букву.</td>
          </tr>
          <tr>
            <td><a href="#flength"><tt>length</tt></a></td>
            <td>Возвращает длину строки.</td>
          </tr>
          <tr>
            <td><a href="#frindex"><tt>rindex</tt></a></td>
            <td>Возвращает первую справа позицию заданной подстроки.</td>
          </tr>
          <tr>
            <td><a href="#fsubstr"><tt>substr</tt></a></td>
            <td>Возвращает заданную подстроку.</td>
          </tr>
          <tr>
            <td><a href="#fuc"><tt>uc</tt></a></td>
            <td>Преобразует строку в прописные буквы.</td>
          </tr>
          <tr>
            <td><a href="#fucfirst"><tt>ucfirst</tt></a></td>
            <td>Преобразует первый символ строки в прописную букву.</td>
          </tr>
        </table>
      </div>

      <h4 class="vindent"><a name="hchomp">Функция chomp</a></h4>

<pre class="syntax"><strong><a name="fchomp">Синтаксис</a></strong>: chomp <em>строка</em>
           chomp <em>список</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
           <em>список</em>&nbsp;&#151; список строковых выражений
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>chomp</strong> удаляет из <em>строки</em> концевую подстроку, соответствующую текущему
        разделителю записей, т.&nbsp;е. содержимому переменной <tt>$/</tt>. Если аргументом является <em>список</em>, то
        эта функция применяется к каждому элементу списка. Если аргумент опущен, то <em>строка</em> принимается равной
        значению переменной <tt>$_</tt>. Результатом функции является общее количество удаленных символов.</p>
      <p>Ее основным применением является удаление концевых символов перевода строки при построчном чтении текстового файла, например:</p>

      <div class="code">
<pre class="code">while (&lt;&gt;) {
  chomp;  # удаляем \n в конце считанной строки $_
  . . .
}</pre>
      </div>

      <p>Если <tt>$\</tt> равно <strong>undef</strong> или содержит ссылку на число (для записей фиксированной длины), то эта функция ничего не удаляет.</p>

      <h4><a name="hchop">Функция chop</a></h4>

<pre class="syntax"><strong><a name="fchop">Синтаксис</a></strong>: chop <em>строка</em>
           chop <em>список</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
           <em>список</em>&nbsp;&#151; список строковых выражений
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>chop</strong> удаляет из <em>строки</em> ее последний символ и возвращает его. Если аргументом является
        <em>список</em>, то эта функция применяется к каждому элементу списка и возвращает последний из удаленных символов.
        Если аргумент опущен, то <em>строка</em> принимается равной значению переменной <tt>$_</tt>. Пример:</p>

      <div class="code">
<pre class="code">$_ = 'abcde';
chop;
print; # выводит 'abcd'</pre>
      </div>

      <h4><a name="hcrypt">Функция crypt</a></h4>

<pre class="syntax"><strong><a name="fcrypt">Синтаксис</a></strong>: crypt <em>строка</em>, <em>код</em>
<strong>Аргументы</strong>: <em>строка</em>, <em>код</em>&nbsp;&#151; строковые выражения
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>crypt</strong> кодирует исходную <em>строку</em> с помощью строки <em>код</em> и возвращает результат.
        <em>Код</em> должен состоять из двух символов, лежащих в диапазоне <tt>[./0-9A-Za-z]</tt>.
        Парной функции декодировки в PERL'е нет, поэтому практического применения эта функция не имеет.</p>

      <h4><a name="hindex">Функция index</a></h4>

<pre class="syntax"><strong><a name="findex">Синтаксис</a></strong>: index <em>строка</em>, <em>подстрока</em>, <em>позиция</em>?
<strong>Аргументы</strong>: <em>строка</em>, <em>подстрока</em>&nbsp;&#151; строковые выражения
           <em>позиция</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>index</strong> ищет в <em>строке</em> заданную <em>подстроку</em>, начиная с заданной <em>позиции</em>
        или с начала строки, если <em>позиция</em> опущена. Она возвращает позицию найденной подстроки в исходной строке или -1,
        если подстрока не найдена. Пример:</p>

      <div class="code">
<pre class="code">$str = 'Queen Mary';
print index($str, 'Mary');  # 6
print index($str, 'mary');  # -1</pre>
      </div>

      <h4><a name="hlc">Функция lc</a></h4>

<pre class="syntax"><strong><a name="flc">Синтаксис</a></strong>: lc <em>строка</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>lc</strong> преобразует все символы <em>строки</em> в строчные буквы. Если аргумент
        опущен, то <em>строка</em> принимается равной значению переменной <tt>$_</tt>. Если использована директива
        <tt>use locale</tt>, то преобразование производится с учетом текущей национальной настройки. Пример:</p>

      <div class="code">
<pre class="code">print lc 'ABCDE';  # abcde</pre>
      </div>

      <h4><a name="hlcfirst">Функция lcfirst</a></h4>

<pre class="syntax"><strong><a name="flcfirst">Синтаксис</a></strong>: lcfirst <em>строка</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>lcfirst</strong> преобразует первый символ <em>строки</em> в строчную букву. Если аргумент
        опущен, то <em>строка</em> принимается равной значению переменной <tt>$_</tt>. Если использована директива
        <tt>use locale</tt>, то преобразование производится с учетом текущей национальной настройки. Пример:</p>

      <div class="code">
<pre class="code">print lcfirst 'ABCDE';  # aBCDE</pre>
      </div>

      <h4><a name="hlength">Функция length</a></h4>

<pre class="syntax"><strong><a name="flength">Синтаксис</a></strong>: length <em>строка</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>length</strong> возвращает количество символов в <em>строке</em>. Если аргумент
        опущен, то <em>строка</em> принимается равной значению переменной <tt>$_</tt>. Пример:</p>

      <div class="code">
<pre class="code">print length 'ABCDE';  # 5</pre>
      </div>

      <h4><a name="hrindex">Функция rindex</a></h4>

<pre class="syntax"><strong><a name="frindex">Синтаксис</a></strong>: rindex <em>строка</em>, <em>подстрока</em>, <em>позиция</em>?
<strong>Аргументы</strong>: <em>строка</em>, <em>подстрока</em>&nbsp;&#151; строковые выражения
           <em>позиция</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>rindex</strong> ищет в <em>строке</em> заданную <em>подстроку</em> справа налево, начиная с заданной <em>позиции</em>
        или с конца строки, если <em>позиция</em> опущена. Она возвращает позицию найденной подстроки в исходной строке или -1,
        если подстрока не найдена. Пример:</p>

      <div class="code">
<pre class="code">print rindex('abcabc', 'abc');  # 3</pre>
      </div>

      <h4><a name="hsubstr">Функция substr</a></h4>

<pre class="syntax"><strong><a name="fsubstr">Синтаксис</a></strong>: substr <em>строка</em>, <em>смещение</em>, <em>длина</em>?, <em>замена</em>?
<strong>Аргументы</strong>: <em>строка</em>, <em>замена</em>&nbsp;&#151; строковые выражения
           <em>смещение</em>, <em>длина</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>substr</strong> возвращает подстроку <em>строки</em> заданной <em>длины</em>, начиная
        с заданного <em>смещения</em>. Если <em>смещение</em> отрицательно, то оно отсчитывается от конца строки.
        Если <em>длина</em> опущена, то извлекаются символы до конца строки; если она отрицательна, то она складывается
        с длиной строки. Пример:</p>

      <div class="code">
<pre class="code">print substr('abcdef', 1, -2);  # bcd</pre>
      </div>

      <p>Если <em>строка</em> задана переменной, то эта функция может иметь четвертый аргумент, который задает строку,
        на которую заменяется заданная подстрока, например:</p>

      <div class="code">
<pre class="code">$str = 'abcdef';
substr($str, 1, -2,'xxx');
print $str; # axxxef</pre>
      </div>

      <p>Этот пример можно записать и так:</p>

      <div class="code">
<pre class="code">$str = 'abcdef';
substr($str, 1, -2) = 'xxx';
print $str; # axxxef</pre>
      </div>

      <h4><a name="huc">Функция uc</a></h4>

<pre class="syntax"><strong><a name="fuc">Синтаксис</a></strong>: uc <em>строка</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>uc</strong> преобразует все символы <em>строки</em> в прописные буквы. Если аргумент
        опущен, то <em>строка</em> принимается равной значению переменной <tt>$_</tt>. Если использована директива
        <tt>use locale</tt>, то преобразование производится с учетом текущей национальной настройки. Пример:</p>

      <div class="code">
<pre class="code">print uc 'abcde';  # ABCDE</pre>
      </div>

      <h4><a name="hucfirst">Функция ucfirst</a></h4>

<pre class="syntax"><strong><a name="fucfirst">Синтаксис</a></strong>: ucfirst <em>строка</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>ucfirst</strong> преобразует первый символ <em>строки</em> в прописную букву. Если аргумент
        опущен, то <em>строка</em> принимается равной значению переменной <tt>$_</tt>. Если использована директива
        <tt>use locale</tt>, то преобразование производится с учетом текущей национальной настройки. Пример:</p>

      <div class="code">
<pre class="code">print ucfirst 'abcde';  # Abcde</pre>
      </div>

      <h3><a name="ref693">6.9.3. Прочие скалярные функции</a></h3>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Функция</th>
            <th>Описание</th>
          </tr>
          <tr>
            <td><a href="#fchr"><tt>chr</tt></a></td>
            <td>Преобразует число в символ.</td>
          </tr>
          <tr>
            <td><a href="#fhex"><tt>hex</tt></a></td>
            <td>Преобразует строку в шестнадцатеричное число.</td>
          </tr>
          <tr>
            <td><a href="#foct"><tt>oct</tt></a></td>
            <td>Преобразует строку в восьмеричное число.</td>
          </tr>
          <tr>
            <td><a href="#ford"><tt>ord</tt></a></td>
            <td>Преобразует символ в число.</td>
          </tr>
          <tr>
            <td><a href="#fpack"><tt>pack</tt></a></td>
            <td>Упаковывает список значений в строку.</td>
          </tr>
          <tr>
            <td><a href="#funpack"><tt>unpack</tt></a></td>
            <td>Распаковывает строку в список значений.</td>
          </tr>
          <tr>
            <td><a href="#fvec"><tt>vec</tt></a></td>
            <td>Операции со строкой как как массивом из групп битов.</td>
          </tr>
        </table>
      </div>

      <h4 class="vindent"><a name="hchr">Функция chr</a></h4>

<pre class="syntax"><strong><a name="fchr">Синтаксис</a></strong>: chr <em>код</em>
<strong>Аргументы</strong>: <em>код</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>chr</strong> возвращает символ, имеющий заданный числовой <em>код</em>. Если аргумент опущен,
        то <em>код</em> принимается равным значению переменной <tt>$_</tt>. Пример:</p>

      <div class="code">
<pre class="code">print chr 65;	// A</pre>
      </div>

      <h4><a name="hhex">Функция hex</a></h4>

<pre class="syntax"><strong><a name="fhex">Синтаксис</a></strong>: hex <em>строка</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>hex</strong> преобразует <em>строку</em> в шестнадцатеричное число. Если аргумент опущен,
        то <em>строка</em> принимается равной значению переменной <tt>$_</tt>. Например, все приведенные ниже операторы
        выведут на экран число 165:</p>

      <div class="code">
<pre class="code">print hex '0xaf';
print hex 'xaf';
print hex '0af';
print hex 'af';</pre>
      </div>

      <h4><a name="hoct">Функция oct</a></h4>

<pre class="syntax"><strong><a name="foct">Синтаксис</a></strong>: oct <em>строка</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>oct</strong> преобразует <em>строку</em> в число. Если <em>строка</em> начинается с '0x',
        то она интерпретируется как шестнадцатеричное число; если она начинается с '0b', то интерпретируется как двоичное число;
        в остальных случаях она интерпретируется как восьмеричное число. Если аргумент опущен, то <em>строка</em> принимается равной
        значению переменной <tt>$_</tt>. Примеры:</p>

      <div class="code">
<pre class="code">print oct '0xaf';  # 165
print oct '0b101'; # 5
print oct '0100';  # 64
print oct '100';   #64</pre>
      </div>

      <h4><a name="hord">Функция ord</a></h4>

<pre class="syntax"><strong><a name="ford">Синтаксис</a></strong>: ord <em>строка</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>ord</strong> возвращает числовой код первого символа <em>строки</em>. Если аргумент опущен,
        то <em>строка</em> принимается равной значению переменной <tt>$_</tt>. Пример:</p>

      <div class="code">
<pre class="code">print ord 'ABC';  # 65</pre>
      </div>

      <h4><a name="hpack">Функция pack</a></h4>

<pre class="syntax"><strong><a name="fpack">Синтаксис</a></strong>: pack <em>шаблон</em>, <em>список</em>
<strong>Аргументы</strong>: <em>шаблон</em>&nbsp;&#151; строковое выражение
           <em>список</em>&nbsp;&#151; список скалярных выражений
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>pack</strong> упаковывает заданный <em>список</em> значений в строку и возвращает его в качестве результата.
        Правила упаковки задаются строкой <em>шаблон</em>, которая состоит из символов, указывающих правила преобразования для
        элементов списка. <em>Шаблон</em> может содержать следующие символы:</p>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Символ</th>
            <th>Результат</th>
          </tr>
          <tr>
            <td><tt>a</tt></td>
            <td>Произвольная строка, в конце добавить нулевой байт.</td>
          </tr>
          <tr>
            <td><tt>A</tt></td>
            <td>Строка ASCII, в конце добавить пробел.</td>
          </tr>
          <tr>
            <td><tt>Z</tt></td>
            <td>Строка ASCII, в конце добавить нулевой байт.</td>
          </tr>
          <tr>
            <td><tt>b</tt></td>
            <td>Битовая строка, биты в байте упаковываются с младшего бита.</td>
          </tr>
          <tr>
            <td><tt>B</tt></td>
            <td>Битовая строка, биты в байте упаковываются со старшего бита.</td>
          </tr>
          <tr>
            <td><tt>h</tt></td>
            <td>Шестнадцатеричная строка, младшая тетрада идет первой.</td>
          </tr>
          <tr>
            <td><tt>H</tt></td>
            <td>Шестнадцатеричная строка, старшая тетрада идет первой.</td>
          </tr>
          <tr>
            <td><tt>c</tt></td>
            <td>Однобайтовое целое со знаком.</td>
          </tr>
          <tr>
            <td><tt>C</tt></td>
            <td>Однобайтовое целое без знака.</td>
          </tr>
          <tr>
            <td><tt>s</tt></td>
            <td>Двухбайтовое целое со знаком.</td>
          </tr>
          <tr>
            <td><tt>S</tt></td>
            <td>Двухбайтовое целое без знака.</td>
          </tr>
          <tr>
            <td><tt>i</tt></td>
            <td>Целое со знаком (число байтов зависит от архитектуры).</td>
          </tr>
          <tr>
            <td><tt>I</tt></td>
            <td>Целое без знака (число байтов зависит от архитектуры).</td>
          </tr>
          <tr>
            <td><tt>l</tt></td>
            <td>Четырехбайтовое целое со знаком.</td>
          </tr>
          <tr>
            <td><tt>L</tt></td>
            <td>Четырехбайтовое целое без знака.</td>
          </tr>
          <tr>
            <td><tt>n</tt></td>
            <td>Двухбайтовое целое без знака, старший байт идет первым.</td>
          </tr>
          <tr>
            <td><tt>N</tt></td>
            <td>Четырехбайтовое целое без знака, старший байт идет первым.</td>
          </tr>
          <tr>
            <td><tt>v</tt></td>
            <td>Двухбайтовое целое без знака, младший байт идет первым.</td>
          </tr>
          <tr>
            <td><tt>V</tt></td>
            <td>Четырехбайтовое целое без знака, младший байт идет первым.</td>
          </tr>
          <tr>
            <td><tt>q</tt></td>
            <td>Восьмибайтовое целое со знаком.</td>
          </tr>
          <tr>
            <td><tt>Q</tt></td>
            <td>Восьмибайтовое целое без знака.</td>
          </tr>
          <tr>
            <td><tt>f</tt></td>
            <td>Плавающее число обычной точности, формат зависит от архитектуры.</td>
          </tr>
          <tr>
            <td><tt>d</tt></td>
            <td>Плавающее число двойной точности, формат зависит от архитектуры.</td>
          </tr>
          <tr>
            <td><tt>p</tt></td>
            <td>Указатель на строку с завершающим нулевым байтом.</td>
          </tr>
          <tr>
            <td><tt>P</tt></td>
            <td>Указатель на структуру фиксированной длины.</td>
          </tr>
          <tr>
            <td><tt>u</tt></td>
            <td>Строка в кодировке uuencode.</td>
          </tr>
          <tr>
            <td><tt>U</tt></td>
            <td>Строка в кодировке UTF-8.</td>
          </tr>
          <tr>
            <td><tt>w</tt></td>
            <td>Сжатое целое формата BER.</td>
          </tr>
          <tr>
            <td><tt>x</tt></td>
            <td>Нулевой байт.</td>
          </tr>
          <tr>
            <td><tt>X</tt></td>
            <td>Дублировать байт.</td>
          </tr>
          <tr>
            <td><tt>@</tt></td>
            <td>Заполнение нулями до указанной позиции.</td>
          </tr>
        </table>
      </div>

      <p>Шаблоны подчиняются следующим правилам:</p>
      <ul>
        <li>За буквой может следовать число, задающее счетчик повторений. Для всех типов, кроме
          <tt>a, A, Z, b, B, h, H, P</tt>, извлекается соответствующее количество элементов
          <em>списка</em>. Если счетчик задан символом <tt>*</tt>, это означает упаковку всех оставшихся
          элементов списка (за исключением <tt>@, x, X</tt>, где этот символ эквивалентен 0, и <tt>u</tt>,
          где он эквивалентен 1).
          <tt>Z*</tt> означает добавление дополнительного нулевого байта в конец строки. Счетчик
          повторений для <tt>u</tt> интерпретируется как максимальное число байтов, которое должно
          кодироваться в одной строке вывода; при этом 0 и 1 заменяются на 45.</li>
        <li>Типы <tt>a, A, Z</tt> всегда извлекают из списка одно значение. Счетчик повторений для них
          означает длину упакованной строки. Если строка длиннее счетчика, то она усекается; если короче,
          то дополняется нулями (<tt>a, Z</tt>) или пробелами (<tt>A</tt>). При упаковке <tt>a</tt> и <tt>Z</tt>
          эквивалентны; при распаковке <tt>A</tt> удаляет из строки концевые пробелы и нулевые байты, <tt>Z</tt> удаляет все после
          первого нулевого байта, <tt>a</tt> ничего не удаляет.</li>
        <li>Типы <tt>b</tt> и <tt>B</tt> преобразуют каждый из входных байтов в один бит результата. Результирующий
          бит равен 0 или 1 в зависимости от значения младшего бита исходного байта. Счетчик повторений задает количество
          упаковываемых байтов. При этом <tt>b</tt> упаковывает получаемые биты в байт результата, начиная с младшего его бита,
          а <tt>B</tt>&nbsp;&#151; со старшего. Если длина исходной строки не делится на 8, то результат дополняется нулевыми битами.
          При распаковке эти лишние биты игнорируются. Если входная строка длиннее счетчика, то она усекается. <tt>*</tt> в
          качестве счетчика повторений означает использование всех байтов входного поля. При распаковке биты
          преобразуются в байты "0" и "1".</li>
        <li>Для типов <tt>h</tt> и <tt>H</tt> счетчик повторений означает количество упаковываемых шестнадцатеричных цифр (тетрад).
          Каждый из входных байтов преобразуется в одну тетраду результата. При этом байты "0"&#133; "9", "a"&#133;"f", "A"&#133;"F"
          заменяются на соответствующие шестнадцатеричные цифры, а остальные байты на свою младшую тетраду. Тип <tt>h</tt> упаковывает
          получаемые тетрады в байт результата, начиная с младшего его тетрады, а <tt>H</tt>&nbsp;&#151; со старшей.
          Если длина исходной строки нечетна, то результат дополняется нулевой тетрадой. При распаковке лишняя тетрада игнорируются.
          Если входная строка длиннее счетчика, то она усекается. <tt>*</tt> в качестве счетчика повторений означает использование всех
          байтов входного поля. При распаковке тетрады преобразуются в строку шестнадцатеричных цифр.</li>
        <li>Тип p упаковывает указатель на строку, оканчивающуюся нулевым байтом, а P&nbsp;&#151; указатель на структуру фиксированной длины,
          заданной счетчиком повторений. Если значение соответствующего указателя равно <strong>undef</strong>, то упаковывается нуль.</li>
        <li>Символ <tt>/</tt> вместо счетчика повторений позволяет упаковать перед строкой ее длину. Например, шаблон <tt>"n/a*"</tt>
          означает, что результат будет состоять из двухбайтового числа, содержащего длину исходной строки, и самой строки.</li>
        <li>При упаковке не производится никакого выравнивания получаемых значений.</li>
        <li>Шаблон может содержать комментарий, который начинается с символа <tt>#</tt> и продолжается до конца строки.</li>
        <li>Если шаблон требует больше аргументов, чем содержится в <em>списке</em>, то <em>список</em> дополняется пустыми строками <tt>""</tt>.
          Если шаблон требует меньше аргументов, чем содержится в <em>списке</em>, то лишние аргументы игнорируются.</li>
      </ul>
      <p>Примеры:</p>

      <div class="code">
<pre class="code">$foo = pack("CCCC",65,66,67,68);       # $foo = "ABCD"
$foo = pack("C4",65,66,67,68);         # $foo = "ABCD"
$foo = pack("aaaa","abc","x","y","z"); # $foo = "axyz"
$foo = pack("a14","abcdefg");          # "abcdefg\0\0\0\0\0\0\0"
$foo = pack("s2",1,2);                 # $foo = "\1\0\2\0" в IBM PC, "\0\1\0\2" в Mac</pre>
      </div>

      <h4><a name="hunpack">Функция unpack</a></h4>

<pre class="syntax"><strong><a name="funpack">Синтаксис</a></strong>: unpack <em>шаблон</em>, <em>строка</em>
<strong>Аргументы</strong>: <em>шаблон</em>, <em>строка</em>&nbsp;&#151; строковые выражения
<strong>Результат</strong>: массив значений</pre>

      <p>Функция <strong>pack</strong> распаковывает <em>строку</em>, упакованную функцией <tt><a href="#fpack">pack()</a></tt>.
        Она возвращает массив полученных в результате значений (в скалярном контексте возвращает первое полученное значение).
        Правила распаковки задаются строкой <em>шаблон</em>, строение которой то же, что и для <tt><a href="#fpack">pack()</a></tt>.
        Дополнительно шаблон может содержать перед буквой, задающей тип распаковки, префикс <tt>%<em>n</em></tt>, который указывает,
        что мы хотим получить не результат распаковки, а его <em>n</em>-битовую контрольную сумму. Остальные подробности см. в описании
        функции <tt><a href="#fpack">pack()</a></tt>. Следующий пример демонстрирует эффективный способ подсчета количества единичных битов
        в переменной <tt>$mask</tt>:</p>

      <div class="code">
<pre class="code">$setbits = unpack("%32b*", $mask);</pre>
      </div>

      <h4><a name="hvec">Функция vec</a></h4>

<pre class="syntax"><strong><a name="fvec">Синтаксис</a></strong>: vec <em>выражение</em>, <em>смещение</em>, <em>ширина</em>
<strong>Аргументы</strong>: <em>выражение</em>&nbsp;&#151; строковое выражение
           <em>смещение</em>, <em>ширина</em>&nbsp;&#151; числовые выражения
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>vec</strong> рассматривает строку <em>выражение</em> как массив, состоящий из
        элементов заданной <em>ширины</em> в битах. Она извлекает элемент с заданным <em>смещением</em> и возвращает его.
        Ширина должна степенью числа 2 в диапазоне от 1 до 32 (или 64 на 64-битовых платформах), <em>смещение</em> трактуется
        как целое число без знака. Пример:</p>
      
      <div class="code">
<pre class="code">$x = "\x10\x32\x54";  # $x = (0, 1, 2, 3, 4, 5) как вектор 4-битовых чисел
print vec($x, 2, 4);  # поэтому будет выведено число 2
</pre>
      </div>

      <p>Функция <strong>vec</strong> может использоваться в левой части оператора присваивания для
        формирования массива битовых групп в строке. Например, мы могли бы сформировать приведенную выше
        строку <tt>$x</tt> так:</p>

      <div class="code">
<pre class="code">vec($x, $_, 4) = $_ foreach (0, 1, 2, 3, 4, 5);</pre>
      </div>

      <h3><a name="ref694">6.9.4. Функции работы с регулярными выражениями</a></h3>

      <div class="indent">
        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Функция</th>
            <th>Описание</th>
          </tr>
          <tr>
            <td><a href="#fpos"><tt>pos</tt></a></td>
            <td>Позиция последнего сопоставления.</td>
          </tr>
          <tr>
            <td><a href="#fquotemeta"><tt>quotemeta</tt></a></td>
            <td>Преобразует символы в escape-последовательности.</td>
          </tr>
          <tr>
            <td><a href="#fsplit"><tt>split</tt></a></td>
            <td>Расщепляет строку на массив подстрок.</td>
          </tr>
          <tr>
            <td><a href="#fstudy"><tt>study</tt></a></td>
            <td>Компилирует строковое выражение.</td>
          </tr>
        </table>
      </div>

      <h4 class="vindent"><a name="hpos">Функция pos</a></h4>

<pre class="syntax"><strong><a name="fpos">Синтаксис</a></strong>: pos <em>аргумент</em>
<strong>Аргументы</strong>: <em>аргумент</em>&nbsp;&#151; строковая переменная
<strong>Результат</strong>: числовое значение</pre>

      <p>Функция <strong>pos</strong> возвращает позицию в строке <em>аргумент</em> после последнего сопоставления
        с модификатором <strong>g</strong>. Если аргумент опущен, то он принимается равным значению переменной <tt>$_</tt>.
        Эта функция может употребляться в левой части операции присваивания для задания новой позиции.
        Такое присваивание изменяет поведение метасимвола <tt>\G</tt> в последующих сопоставлениях. См. подробнее
        <a href="perl04.htm#ref6461">п. 6.4.6.1</a>.</p>

      <h4><a name="hquotemeta">Функция quotemeta</a></h4>

<pre class="syntax"><strong><a name="fquotemeta">Синтаксис</a></strong>: quotemeta <em>аргумент</em>
<strong>Аргументы</strong>: <em>аргумент</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: строковое значение</pre>

      <p>Функция <strong>quotemeta</strong> добавляет в строку аргумента символ <tt>'\'</tt> перед каждым символом,
        не являющимся латинской буквой или цифрой, и возвращает новую строку в качестве результата.
        Если аргумент опущен, то он принимается равным значению переменной <tt>$_</tt>. Это внутренняя
        функция, которая реализует метасимвол <tt>\Q</tt>. Пример:</p>

      <div class="code">
<pre class="code">print quotemeta "abc123абв";  # "abc123\а\б\в"</pre>
      </div>

      <h4><a name="hsplit">Функция split</a></h4>

<pre class="syntax"><strong><a name="fsplit">Синтаксис</a></strong>: split <em>образец</em>, <em>строка</em>, <em>предел</em>
<strong>Аргументы</strong>: <em>образец</em>&nbsp;&#151; регулярное выражение
           <em>строка</em>&nbsp;&#151; строковое выражение
           <em>предел</em>&nbsp;&#151; числовое выражение
<strong>Результат</strong>: список строк</pre>

      <p>Функция <strong>split</strong> расщепляет исходную <em>строку</em> на подстроки и возвращает список
        этих подстрок. В скалярном контексте она заносит список подстрок в массив <tt>@_</tt> и возвращает его длину.
        Если <em>строка</em> опущена, то она принимается равной значению переменной <tt>$_</tt>. Разбиение на подстроки
        происходит в позициях сопоставления с заданным <em>образцом</em>; если он опущен, то разбиение производится по
        символу пробела, при этом начальные пробелы в каждой подстроке удаляются. Если образец содержит круглые скобки, то
        подстроки, сопоставляемые с выражением в скобках, включаются в результирующий список как отдельные элементы.</p>
      <p>Если <em>предел</em> задан и положителен, то он задает максимально допустимое количество извлекаемых подстрок.
        Если он опущен или равен нулю, то конечные пустые подстроки не включаются в результирующий список. Если же он
        отрицательный, то возвращаются все извлеченные подстроки. Примеры:</p>

      <div class="code">
<pre class="code">@_ = split(/,/, 'a,b,c,d,');     # @_ = ('a', 'b', 'c', 'd')
@_ = split(/,/, 'a,b,c,d,', 3);  # @_ = ('a', 'b', 'c,d,')
@_ = split(/,/, 'a,b,c,d,', -3); # @_ = ('a', 'b', 'c', 'd', '')
@_ = split(/(,)/, 'a,b,c,d,');   # @_ = ('a', ',', 'b', ',', 'c', ',', 'd', ',')</pre>
      </div>

      <h4><a name="hstudy">Функция study</a></h4>

<pre class="syntax"><strong><a name="fstudy">Синтаксис</a></strong>: study <em>строка</em>
<strong>Аргументы</strong>: <em>строка</em>&nbsp;&#151; строковое выражение
<strong>Результат</strong>: нет</pre>

      <p>Функция <strong>study</strong> компилирует <em>строку</em> (или значение переменной <tt>$_</tt>, если она опущена)
        во внутреннее представление.  Если <em>строку</em> предполагается многократно сопоставлять с образцом, то ее
        компиляция может сэкономить время при последующих операциях сопоставления. В каждый момент времени только одна
        строка может быть скомпилирована; применение функции <strong>study</strong> к другой строке отменяет
        компиляцию текущей строки. Пример:</p>

      <div class="code">
<pre class="code">while (&lt;&gt;) {
  study;
  print "Мое\n" if /\bменя\b/;
  print "Твое\n" if /\bтебя\b/;
  ...
}</pre>
      </div>

    </td></tr>
  <tr><td><div id="divFooter"></div></td></tr>
</table>
</body>
</html>
