<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Author" content="Юрий Лукач">
<meta name="Description" content="Справочник Веб-разработчика: современные технологии WWW">
<meta name="Keywords" content="WWW, Веб, разработка, программирование, HTML, DHTML, CSS, Java, JavaScript, CGI, PERL, ASP, XML, XSL, VML, VRML">
<title>WDH: Интерфейс CGI</title>
<link rel="Prev" href="perllib.htm" title="Библиотечные модули PERL">
<link rel="Next" href="tables.htm" title="Перечень таблиц">
<link rel="Copyright" href="cpyright.htm" title="Сведения об авторских правах">
<link rev="Made" href="mailto:yury@suncloud.ru" title="Обратная связь">
<script type="text/javascript" src="global/load.js"></script>
<script type="text/javascript" src="global/link.js"></script>
</head>

<body onLoad="initDoc(); addBanner(true)">
<table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin: 0">
  <tr><td><div id="divHeader"></div></td></tr>
  <tr><td id="tdBanner" style="text-align: center"><script type="text/javascript">addBanner(false);</script></td></tr>
  <tr><td>

      <h1><a name="cgi">Приложение 24.<br>
        Интерфейс CGI</a></h1>

      <h2><a name="intro">Введение в CGI</a></h2>

      <p>Большая часть нашего общения с WWW сводится к тому, что обозреватель, работающий на компьютере-клиенте,
        передает Веб-серверу URI Веб-страницы, сервер находит ее в Сети и передает обозревателю, а тот эту страницу отображает.
        Этот способ общения вполне достаточен для обычного серфинга, но существует обширный круг задач, требующих более
        развитой технологии взаимодействия сервера с клиентом, например:</p>

      <ul>
        <li>обращение к поисковой системе с целью поиска узлов, содержащих определенную информацию;</li>
        <li>запрос к базе данных с целью выборки данных, отвечающих заданному критерию;</li>
        <li>передача серверу результатов заполнения пользователем формы с целью оплаты отобранного товара
          или проведения банковской транзакции.</li>
      </ul>

      <p>Все эти примеры, по сути дела, сводятся к одной задаче. Нам нужна технология, позволяющая:</p>

      <ol>
        <li>запустить с компьютера клиента на сервере определенную программу (обычно называемую <em>сценарием
          сервера</em>);</li>
        <li>передать ей (опять же от клиента) определенные параметры;</li>
        <li>передать результаты работы программы от сервера обратно клиенту.</li>
      </ol>

      <p>Для решения этой задачи нужен единый интерфейс клиент-сервер, который не зависел бы ни от платформы,
        ни от операционной системы, ни от языка программирования, на котором реализован сценарий сервера.
        Такой несложный интерфейс был создан в 1993 г. в NCSA (The National Centre for Supercomputing
        Applications) под названием CGI (Common Gateway Interface) и продолжает использоваться без существенных
        изменений по сей день. Мы опираемся в последующем изложении на спецификацию CGI/1.1, ревизию
        03 от 25 июня 1999 г. Общая схема взаимодействия клиента с сервером иллюстрируется следующим рисунком:</p>

      <div class="figure"><img src="images/cgi.gif" alt="Интерфейс CGI"></div>

      <h2><a name="request">Передача запроса от клиента к серверу</a></h2>

      <p>Вспомним, что всякий запрос передается от обозревателя к серверу в форме URI, общий вид которого
        таков (подробности см. в <a href="uri.htm">Приложении 2</a>):</p>

      <pre><var>протокол</var>://<var>пользователь</var>@<var>сервер</var>:<var>порт</var>/<var>путь</var>?<var>запрос</var></pre>

      <p>Суть CGI состоит в том, что он фиксирует стандартные имена <em>метапеременных</em>, которые
        сервер должен заполнить, анализируя URI запроса. Эти метапеременные представляют собой текстовые
        строки, которые должны быть доступны запускаемому сценарию; конкретная реализация механизма
        доступа к переменным зависит от операционной системы. Согласно спецификации CGI запрос на запуск
        сценария будет выглядеть так:</p>

      <p style="font-size: smaller">протокол &quot;://&quot; SERVER_NAME &quot;:&quot; SERVER_PORT SCRIPT_NAME
        PATH_INFO &quot;?&quot; QUERY_STRING</p>

      <p class="noindent">где SERVER_NAME, SERVER_PORT, SCRIPT_NAME, PATH_INFO и QUERY_STRING&nbsp;&#151;
        метапеременные, соответствующие составным элементам URI и описанные ниже.</p>

      <p class="note"><strong>Примечания</strong>.</p>

      <ol>
        <li class="note">Протокол URI и протокол CGI не всегда совпадают. Например, если доступ к ресурсу
          осуществляется через защитный механизм SSL (Secure Sockets Layer), то именем протокола URI
          будет <strong>https</strong>, а именем протокола CGI по-прежнему <strong>http</strong>. Впрочем,
          CGI не содержит механизмов, позволяющих сценарию извлечь имя протокола, поэтому можно считать,
          что оно всегда <strong>http</strong>. Кроме того, URI запроса к CGI не может содержать <a href="uri.htm#fragid">закладок</a>.</li>
        <li class="note">В действительности, URI сценария содержит не SCRIPT_NAME и PATH_INFO, а их
          кодированную форму. Дело в том, что URL может состоять только из символов базовой латиницы,
          а в запросе могут присутствовать и иные символы. В этом случае они преобразуются в кодировку
          UTF-8, как описано в <a href="uri.htm#encoding">Приложении 2</a>, а затем передаются серверу.</li>
      </ol>

      <h2><a name="script">Запуск сценария и передача ему параметров</a></h2>

      <p>Как отмечалось выше, сценарием может быть исполняемый модуль, написанный на любом языке (например,
        на C++). Но чаще всего в качестве сценария выступает интерпретируемый модуль (например, на языке
        PERL). При этом операционная система сервера распознает тип сценария и вызывает соответствующий
        интерпретатор (например, perl.exe).</p>

      <p>Далее, сервер обязан извлечь информацию из URI запроса и разместить ее в метапеременных. Имена
        метапеременных не должны зависеть от регистра, но это также определяется системой. Поэтому лучше
        всегда писать их прописными буквами, как делаем мы в этом справочнике. Значения метапеременных
        должны считаться зависящими от регистра.</p>

      <h2><a name="metavars">Стандартные метапеременные</a></h2>

      <p>Следующие имена метапеременных являются стандартными и должны формироваться всеми серверами,
        поддерживающими интерфейс CGI.</p>

      <div class="center">
        <table border="1" cellpadding="5" cellspacing="0">
          <caption><a name="table241a">Таблица П24.1. Стандартные метапеременные CGI</a></caption>
          <tr>
            <td>AUTH_TYPE</td>
            <td>Тип авторизации. Если сервер признал полномочия пользователя, значение этой переменной
              &quot;Basic&quot;, в противном случае оно не определено.</td>
          </tr>
          <tr>
            <td>CONTENT_LENGTH</td>
            <td>Десятичное число байтов в теле сообщения, если оно присоединено к запросу.</td>
          </tr>
          <tr>
            <td>CONTENT_TYPE</td>
            <td><a href="mime.htm">Тип MIME</a> тела сообщения, если оно присоединено к запросу.</td>
          </tr>
          <tr>
            <td>GATEWAY_INTERFACE</td>
            <td>Текущая версия CGI. В настоящее время это &quot;CGI/1.1&quot;</td>
          </tr>
          <tr>
            <td>PATH_INFO</td>
            <td>Указывает на ресурс или подресурс, который должен быть возвращен сценарием. Это часть
              URI между именем сценария и строкой запроса.</td>
          </tr>
          <tr>
            <td>PATH_TRANSLATED</td>
            <td>Значение PATH_INFO, в котором все виртуальные имена отображены в реальные каталоги сервера.</td>
          </tr>
          <tr>
            <td>QUERY_STRING</td>
            <td>Строка запроса к сценарию. Это все, что следует в URI запроса после &quot;?&quot;.</td>
          </tr>
          <tr>
            <td>REMOTE_ADDR</td>
            <td>IP-адрес клиента.</td>
          </tr>
          <tr>
            <td>REMOTE_HOST</td>
            <td>Полное имя домена клиента.</td>
          </tr>
          <tr>
            <td>REMOTE_IDENT</td>
            <td>Если Веб-сервер поддерживает идентификацию по <a href="http://www.faqs.org/rfcs/rfc1413.html" target="_blank">RFC
              1413</a> <img src="images/extref.gif" alt="Внешняя ссылка">, сюда
              заносится имя удаленного пользователя. Используется только для регистрации.</td>
          </tr>
          <tr>
            <td>REMOTE_USER</td>
            <td>Если AUTH_TYPE = &quot;Basic&quot;, то здесь содержится имя пользователя, переданное
              клиентом и проверенное сервером на наличие прав доступа.</td>
          </tr>
          <tr>
            <td>REQUEST_METHOD</td>
            <td><a href="http.htm#http-methods">Метод запроса HTTP</a> (&quot;GET&quot;, &quot;HEAD&quot;,
              &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;, &quot;TRACE&quot;).</td>
          </tr>
          <tr>
            <td>SCRIPT_NAME</td>
            <td>Имя запускаемого сценария.</td>
          </tr>
          <tr>
            <td>SERVER_NAME</td>
            <td>Имя или IP-адрес сервера.</td>
          </tr>
          <tr>
            <td>SERVER_PORT</td>
            <td>Порт TCP/IP, на который пришел запрос.</td>
          </tr>
          <tr>
            <td>SERVER_PROTOCOL</td>
            <td>Имя и версия протокола, связанного с запросом. Обычно это &quot;HTTP/1.1&quot;.</td>
          </tr>
          <tr>
            <td>SERVER_SOFTWARE</td>
            <td>Имя и версия Веб-сервера в формате &quot;имя/версия&quot;.</td>
          </tr>
        </table>
      </div>

      <h2><a name="processing">Обработка тела сообщения</a></h2>

      <p>Если запрос помимо URI содержит присоединенные данные, то сервер должен занести размер этих
        данных в байтах в переменную CONTENT_LENGTH и обеспечить сценарию доступ к этим данным. Если
        не оговорено иное, доступ осуществляется через дескриптор файла &quot;стандартный ввод&quot;
        (stdin).</p>
      <p>Сценарий считывает переданные ему данные, при необходимости анализирует метапеременные и формирует
         документ, который сервер должен передать клиенту.</p>

      <h2><a name="dataflow">Передача данных от сценария к серверу</a></h2>

      <p>Сценарий всегда должен вернуть какой-либо результат серверу, а сервер должен обеспечить механизм
        передачи результатов от сценария к серверу. Если не оговорено иное, эта передача осуществляется
        через дескриптор файла &quot;стандартный вывод&quot; (stdout). Сервер, в свою очередь, формирует
        из полученных от сценария данных стандатный HTTP-отклик и передает его клиенту.</p>
      <p>Результатом работы сценария может быть либо сгенерированный HTML-документ, либо указание серверу
        вернуть пользователю определенный ресурс. Данные, передаваемые сценарием серверу, начинаются со
        служебного заголовка, состоящего из текстовых строк и заканчивающегося пустой строкой (т.&nbsp;е.
        строкой, состоящей из LF или CR/LF). Служебный заголовок может содержать три директивы,
        аналогичные <a href="http.htm#http-headers">полям заголовка HTTP</a>:</p>

      <table border="1" cellpadding="5" cellspacing="0">
        <tr>
          <th style="width: 23%">Поле</th>
          <th>Описание</th>
        </tr>
        <tr>
          <td style="width: 23%"><tt>Content-Type</tt></td>
          <td>Содержит тип MIME возвращаемого документа.</td>
        </tr>
        <tr>
          <td style="width: 23%"><tt>Location</tt></td>
          <td>Возвращает URI ресурса. Используется в том случае, когда сценарий передает серверу
            не сформированный документ, а ссылку на ресурс.</td>
        </tr>
        <tr>
          <td style="width: 23%"><tt>Status</tt></td>
          <td>Возвращает <a href="http.htm#http-status">код состояния</a> в формате <em>число&nbsp;строка</em>,
            где <em>число</em>&nbsp;&#151; номер кода состояния, а <em>строка</em>&nbsp;&#151; соответствующее
            сообщение. Этот код состояния заносится в строку состояния <a href="http.htm#http-response">HTTP-отклика</a>.</td>
        </tr>
      </table>
      <p>Пример документа, сформированного сценарием:</p>
      <div class="code">
<pre>
Content-type: text/html; charset=windows-1251
Status: 200 OK

&lt;HTML>&lt;HEAD>
&lt;TITLE>Вывод HTML из CHI-сценария&lt;/TITLE>
&lt;/HEAD>&lt;BODY>
&lt;H1>Пример&lt;/H1>
&lt;P>Как вам &lt;STRONG>это&lt;/STRONG> нравиться?&lt;/P>
&lt;/BODY>&lt;/HTML>
</pre>
      </div>
      <p>Реальные примеры CGI-сценариев приведены в <a href="perl13.htm">гл. 6.13</a>.</p>

    </td></tr>
  <tr><td><div id="divFooter"></div></td></tr>
</table>
</body>
</html>
